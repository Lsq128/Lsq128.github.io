{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/2.jpg","path":"img/2.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":0},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":0},{"_id":"source/img/ker1.jpg","path":"img/ker1.jpg","modified":0,"renderable":0},{"_id":"source/img/3.jpg","path":"img/3.jpg","modified":0,"renderable":0},{"_id":"themes/aircloud/source/css/aircloud.css","path":"css/aircloud.css","modified":0,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.css.map","path":"css/aircloud.css.map","modified":0,"renderable":1},{"_id":"themes/aircloud/source/css/aircloud.less","path":"css/aircloud.less","modified":0,"renderable":1},{"_id":"themes/aircloud/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/aircloud/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/kds.jpg","path":"img/kds.jpg","modified":0,"renderable":0},{"_id":"themes/aircloud/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"source/img/kd.jpg","path":"img/kd.jpg","modified":0,"renderable":0},{"_id":"source/img/donate.jpg","path":"img/donate.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/aircloud/_config.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859148},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1581943855652},{"_id":"themes/aircloud/.git","hash":"88a226fa8205173f10fe28625a2fde6ee48f88b7","modified":1581943859087},{"_id":"themes/aircloud/.gitignore","hash":"5a4a925cfd624633dafaacaced416c8d7272dcef","modified":1581943859148},{"_id":"themes/aircloud/LICENSE","hash":"218b4bf797149a2751a015812a9adefe368185c1","modified":1581943859148},{"_id":"themes/aircloud/readme-en.md","hash":"2903b1e9db12cd72ed6f8c10be14cd7f6afd82cf","modified":1581943859150},{"_id":"themes/aircloud/readme.md","hash":"4be1fc64bd1dc335a986a39594564e89bd7eba43","modified":1581943859151},{"_id":"themes/aircloud/layout/catagory.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859149},{"_id":"themes/aircloud/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859150},{"_id":"source/_posts/从源码分析sentry的错误信息收集.md","hash":"7358596ed8d590b0fee479f81826b184fd32a56d","modified":1581943855655},{"_id":"source/_posts/入门WebAssembly以及使用其进行图像卷积处理.md","hash":"9a7267f266cb01240016a713f465e540985a9500","modified":1581943855656},{"_id":"source/_posts/多组件单页列表应用的代码组织实践.md","hash":"444ab2e467431ed018c752b7cb301f33d7f0ac05","modified":1581943855656},{"_id":"source/_posts/浅谈前端中的二进制数据类型.md","hash":"750120163d9eee8ed821ced7e47c043bbfa6b537","modified":1581943855657},{"_id":"source/_posts/构建利用Proxy和Reflect实现双向数据绑定的微框架.md","hash":"e9cdaaacbf7f265262cc9ad527716ca8b32573eb","modified":1581943855657},{"_id":"source/_posts/深入Vue源代码解决时序问题一.md","hash":"d4cacd38879d566c964163e2ac58f8013f7e11a6","modified":1581943855657},{"_id":"source/_posts/深入浏览器web渲染与优化-续.md","hash":"917308065bce9eada9020f3122f1a24d8cf0c7e5","modified":1581943855658},{"_id":"source/_posts/深入浏览器web渲染与优化.md","hash":"4d8b47d007a6f60f31bcf7f795f395d05989e87c","modified":1581943855658},{"_id":"source/about/index.md","hash":"4de5a08a2bc646040a635c22afbd5e5cb9299b42","modified":1581943855658},{"_id":"source/img/2.jpg","hash":"2f5b0345c366a264ed5b685e464a84e592ac0017","modified":1581943855660},{"_id":"source/img/favicon.ico","hash":"6ed6db9af6e0d7b20e62a81d36d0556f47781d28","modified":1581943855669},{"_id":"source/tags/index.md","hash":"4e3dfcd992b0772a4b8b034fe41ead1cc7ce9903","modified":1581943855678},{"_id":"themes/aircloud/languages/en.yml","hash":"f3dd50ca369974ac7d335fb1cfabf4ebb04a64fa","modified":1581943859148},{"_id":"themes/aircloud/languages/zh.yml","hash":"9ffaff1f5d240c94e44f9ef3b02bbae146af0dd4","modified":1581943859148},{"_id":"themes/aircloud/layout/404.ejs","hash":"8a30233a7b99831bd771121b5f450aaba412e8d5","modified":1581943859148},{"_id":"themes/aircloud/layout/about.ejs","hash":"cec034166ce08d2f8c961178e07b2f0ceac95cf2","modified":1581943859149},{"_id":"themes/aircloud/layout/archive.ejs","hash":"0f8a062f4f2f0648b23bd8c4a21945a6ca60dc1f","modified":1581943859149},{"_id":"themes/aircloud/layout/index.ejs","hash":"09e2407d615be7fe7ac41d11df3b7026e7393080","modified":1581943859149},{"_id":"themes/aircloud/layout/layout.ejs","hash":"7efd113aee90e698e187d0ea1f0b42a1c00d210e","modified":1581943859150},{"_id":"themes/aircloud/layout/post.ejs","hash":"2eb5fc0c2bb801528c3db3b09e6cb4d073e3ad99","modified":1581943859150},{"_id":"themes/aircloud/layout/tags.ejs","hash":"1a174d9213d25d9bf6ef28aabdaea6661cdd88c8","modified":1581943859150},{"_id":"source/img/1.jpg","hash":"f667d88d44741ff7b92ee9db5f1994bbcc05311c","modified":1581943855659},{"_id":"source/img/ker1.jpg","hash":"708e619ae0ad4524c41665f9930d3b8240d9ddcd","modified":1581943855678},{"_id":"themes/aircloud/source/_less/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859151},{"_id":"themes/aircloud/source/_less/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859151},{"_id":"themes/aircloud/source/_less/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859152},{"_id":"themes/aircloud/source/_less/diff.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859152},{"_id":"themes/aircloud/source/_less/page.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859154},{"_id":"themes/aircloud/source/_less/page.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859154},{"_id":"themes/aircloud/source/_less/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859155},{"_id":"themes/aircloud/source/_less/theme.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581943859155},{"_id":"source/img/3.jpg","hash":"2de0cbd6ef6695f024865eb614e849641d369b87","modified":1581943855662},{"_id":"themes/aircloud/layout/_partial/donate.ejs","hash":"81c976a3b7fa5c47ef61181d537220eaf1d55eac","modified":1581943859148},{"_id":"themes/aircloud/layout/_partial/footer.ejs","hash":"33db88f1b03548c5181c04d44387dc68a9c4cdf6","modified":1581943859149},{"_id":"themes/aircloud/layout/_partial/head.ejs","hash":"3f18d5d4951a205bab25b08d6bf85b054c84a21b","modified":1581943859149},{"_id":"themes/aircloud/layout/_partial/nav.ejs","hash":"079fa72aa7a02ee11f6a44a8a9e58eb80fe28190","modified":1581943859149},{"_id":"themes/aircloud/layout/_partial/toc.ejs","hash":"41d11d159011466f0b6272aca9a74df8642b693f","modified":1581943859149},{"_id":"themes/aircloud/source/_less/archive.css","hash":"905efcc06a62d1e8b60df0e12434afa353378d3a","modified":1581943859152},{"_id":"themes/aircloud/source/_less/archive.less","hash":"5538d38614960e69b97a7f80f38b5933851212b8","modified":1581943859152},{"_id":"themes/aircloud/source/_less/common.css","hash":"64914aa6ecd5b948676870e0809e0f220b162e3b","modified":1581943859152},{"_id":"themes/aircloud/source/_less/common.less","hash":"8aef4d8cfdefbcd2e28d4985a4f79a5005ca0b6c","modified":1581943859152},{"_id":"themes/aircloud/source/_less/donate.css","hash":"ae6a676a42321512f0536c5230bb53084aaf2c2f","modified":1581943859152},{"_id":"themes/aircloud/source/_less/donate.less","hash":"d63139f4aa148bf894afa5c1007a4398696a0e4c","modified":1581943859152},{"_id":"themes/aircloud/source/_less/gitment.css","hash":"7d560b64e367129f98424052c660ae82b03a1d02","modified":1581943859153},{"_id":"themes/aircloud/source/_less/gitment.less","hash":"916deb8ecdee798d7a9b43b544e31dfd5bbd6de4","modified":1581943859153},{"_id":"themes/aircloud/source/_less/hightlight.css","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1581943859153},{"_id":"themes/aircloud/source/_less/hightlight.less","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1581943859153},{"_id":"themes/aircloud/source/_less/index.css","hash":"52fe4d1b93dfb4c9c9d63e24862354b6a0ef47f8","modified":1581943859153},{"_id":"themes/aircloud/source/_less/index.less","hash":"502d689e3568056cc27dd4da7da2499b0be4253e","modified":1581943859153},{"_id":"themes/aircloud/source/_less/layout.css","hash":"40d7cadf42b130ea1b40de1ae73b2b00e27f476f","modified":1581943859153},{"_id":"themes/aircloud/source/_less/layout.less","hash":"194ac7db2eeee7307fcb7470302f8172100181fb","modified":1581943859154},{"_id":"themes/aircloud/source/_less/nav.css","hash":"32e352d71dc2e67d69a26d8b5116a27d8d2a7718","modified":1581943859154},{"_id":"themes/aircloud/source/_less/nav.less","hash":"627e33cafb4ca9c191053b10917fc21c68c6ee8c","modified":1581943859154},{"_id":"themes/aircloud/source/_less/post.css","hash":"4adf531589cb55413264c188b29ae47ab703beb8","modified":1581943859154},{"_id":"themes/aircloud/source/_less/post.less","hash":"bbbd81c03e7581950d82bf971eda49e8bed7bee1","modified":1581943859154},{"_id":"themes/aircloud/source/_less/tag.css","hash":"3250887aaae0bc62bd82082d000ce3de8cc55ab6","modified":1581943859154},{"_id":"themes/aircloud/source/_less/tag.less","hash":"47e1ce2f55e2b62beefd0f69dfe7deb594e7b309","modified":1581943859154},{"_id":"themes/aircloud/source/_less/toc.css","hash":"83b1a219e7fe66d9d6cc34600e5a16311381a883","modified":1581943859155},{"_id":"themes/aircloud/source/_less/toc.less","hash":"c873ce552b22b0aa2c51a386a91516cadf9160ba","modified":1581943859155},{"_id":"themes/aircloud/source/_less/variables.css","hash":"9768d38beea904c4febc704192a49c8f7ae6e06c","modified":1581943859155},{"_id":"themes/aircloud/source/_less/variables.less","hash":"49503f7a6c51edd6f1dbdea5345df6bb903b18a5","modified":1581943859155},{"_id":"themes/aircloud/source/css/aircloud.css","hash":"e6082557a5f0e546169ab1aa0ba29bda4ef5c182","modified":1581943859155},{"_id":"themes/aircloud/source/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1581943859155},{"_id":"themes/aircloud/source/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1581943859155},{"_id":"themes/aircloud/source/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1581943859156},{"_id":"themes/aircloud/source/js/index.js","hash":"1fed4485eedf5309e504aec35596955e5d692c7d","modified":1581943859157},{"_id":"source/img/avatar.jpg","hash":"652becf5d77647d7da018959e8316b8908621ac5","modified":1581945395880},{"_id":"source/img/kds.jpg","hash":"70558c28dbc717528049673f7653804596e45fde","modified":1581943855677},{"_id":"themes/aircloud/source/_less/_partial/footer.css.map","hash":"9e8d4df5d08425de5a8b247d0dd8b805c6edc661","modified":1581943859151},{"_id":"themes/aircloud/source/_less/_partial/footer.css","hash":"e00d722211b4695449d72850340ac0dd701d6ede","modified":1581943859151},{"_id":"themes/aircloud/source/_less/_partial/footer.less","hash":"d1469f97daf750f3e4be18c4d640772780c32a75","modified":1581943859151},{"_id":"themes/aircloud/source/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1581943859156},{"_id":"source/img/kd.jpg","hash":"37b74057d1c06436c4c8c1b191b86ff6593fca16","modified":1581943855674},{"_id":"source/img/donate.jpg","hash":"27a2fec9b7ab2a499d60b37ebd89bcbcd5e6c30d","modified":1581945263383},{"_id":"source/.DS_Store","hash":"7f16076e5fb33e7ef16c97964921714170fb0357","modified":1581945566260},{"_id":"source/img/.DS_Store","hash":"30b30991c86a2e1ff07a77ed97f8588da0378127","modified":1581945463992}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2020-02-17T12:50:55.652Z","updated":"2020-02-17T12:50:55.652Z","path":"404.html","title":"","comments":1,"_id":"ck6qgo6na00008zomgf115ptw","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","comments":1,"_content":"\n\n>大多数时候，都在思考自己该走向何方\n\nMail: onlythen@yeah.net\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n\n\n>大多数时候，都在思考自己该走向何方\n\nMail: onlythen@yeah.net\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2020-02-17T12:50:55.658Z","path":"about/index.html","_id":"ck6qgo6nz00028zomsk9r3ze9","content":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>Mail: <a href=\"mailto:onlythen@yeah.net\" target=\"_blank\" rel=\"noopener\">onlythen@yeah.net</a></p>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大多数时候，都在思考自己该走向何方</p>\n</blockquote>\n<p>Mail: <a href=\"mailto:onlythen@yeah.net\" target=\"_blank\" rel=\"noopener\">onlythen@yeah.net</a></p>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"noopener\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"tags","title":"Tags","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n","date":"2020-02-17T12:50:55.678Z","updated":"2020-02-17T12:50:55.678Z","path":"tags/index.html","comments":1,"_id":"ck6qgo6o000048zomdtt3801q","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"从源码分析sentry的错误信息收集","date":"2018-08-18T11:23:55.000Z","_content":"\nraven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是`https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js`。\n\n首先抛出几个问题：\n\n* **raven.js 是如何收集浏览器错误信息的？**\n* **raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？**\n* **面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？**\n* **raven.js 如何和框架配合使用（比如 vue、react）？**\n\n在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。\n\nraven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：\n\n* [json-stringify-safe](https://github.com/moll/json-stringify-safe) ：一个对 `JSON.stringify` 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。\n\t* 这里面有一个注意点要单独说一下，我们熟知的 `JSON.stringify` , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 `json-stringify-safe` 就是充分利用了这三个参数。\n* [md5](https://github.com/blueimp/JavaScript-MD5)：js 的 md5 函数。\n* [TraceKit](https://github.com/csnover/TraceKit)：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。\n\n除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。\n\n### raven.js 是如何收集错误信息的？\n\n我们知道，在前端收集错误，肯定离不开 `window.onerror` 这个函数，那么我们就从这个函数说起。\n\n实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：\n\n```\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled) { // 一个起到标志作用的全局变量\n    return;\n  }\n  _oldOnerrorHandler = _window.onerror; \n  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖\n  // 该 _window 经过兼容，实际上就是 window\n  _window.onerror = traceKitWindowOnError;\n  _onErrorHandlerInstalled = true;\n}\n```\n\n相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：\n\n```\nfunction traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n\t\n\tvar exception = utils.isErrorEvent(ex) ? ex.error : ex;\n\t//...\n    stack = TraceKit.computeStackTrace(exception);\n    notifyHandlers(stack, true);\n    //...\n   \n    //...\n    if (_oldOnerrorHandler) {\n       return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n}\n```\n\n其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。\n\nnotifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：\n\n```\nfunction subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n}\n```\n\n以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。\n\n下面我们对错误处理 raven.js 控制的部分做了一些梳理：\n\n```\n _handleOnErrorStackInfo: function(stackInfo, options) {\n    options.mechanism = options.mechanism || {\n      type: 'onerror',\n      handled: false\n    };\n    // mechanism 和错误统计来源有关\n\n    if (!this._ignoreOnError) {\n      this._handleStackInfo(stackInfo, options);\n    }\n},\n\n_handleStackInfo: function(stackInfo, options) {\n    var frames = this._prepareFrames(stackInfo, options);\n\n    this._triggerEvent('handle', {\n      stackInfo: stackInfo,\n      options: options\n    });\n\n    this._processException(\n      stackInfo.name,\n      stackInfo.message,\n      stackInfo.url,\n      stackInfo.lineno,\n      frames,\n      options\n    );\n},\n\n_processException: function(type, message, fileurl, lineno, frames, options) {\n    // 首先根据 message 信息判断是否是需要忽略的错误类型\n    // 然后判断出错的文件是否在黑名单中或者白名单中\n    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象\n    // 最后调用上报函数\n    this._send(data);\n}\n\n_send: function(data) {\n\t\n\t// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息\n\n\t// 交由 _sendProcessedPayload 进行进一步处理\n\tthis._sendProcessedPayload(data);\n}\n\n_sendProcessedPayload: function(data, callback) {\n\n\t// 对 data 增加一些必要的元信息\n\t// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 \n\t(globalOptions.transport || this._makeRequest).call(this, {\n\t     url: url,\n\t     auth: auth,\n\t     data: data,\n\t     options: globalOptions,\n\t     onSuccess: function success() {\n\t       \n\t     },\n\t     onError: function failure(error) {\n\t       \n\t     }\n\t});\n}    \n\n// 真正发起请求的函数\n_makeRequest: function(opts) {\n\t// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求\n\t// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求\n}\n``` \n\n实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：\n\n* 每个函数只处理一件或者一些事情，保持函数的短小整洁。\n* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try {\n    doSomething(a[0])\n} catch(e) {\n    Raven.captureException(e)\n}` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。\n\n但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：\n\n* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。\n* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。\n* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。\n\n最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：\n\n```javascript\nRaven.config('http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2').install()\nlet s = window.ss;\n\ntry{\n    let b = s.b\n} catch (e) {\n    Raven.captureException(e)\n    // sentry should report error now\n}\n\ns.nomethod();\n// sentry should report error now\n```\n\n以上例子中，sentry 会发送两个 POST 请求。\n\n### raven.js 最终上报数据的格式\n\n\n这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。\n\n我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：\n\n```\n{\n  \"project\": \"2\",\n  \"logger\": \"javascript\",\n  \"platform\": \"javascript\",\n  \"request\": {\n    \"headers\": {\n      \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"\n    },\n    \"url\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"\n  },\n  \"exception\": {\n    \"values\": [\n      {\n        \"type\": \"TypeError\",\n        \"value\": \"Cannot read property 'b' of undefined\",\n        \"stacktrace\": {\n          \"frames\": [\n            {\n              \"filename\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n              \"lineno\": 19,\n              \"colno\": 19,\n              \"function\": \"?\",\n              \"in_app\": true\n            }\n          ]\n        }\n      }\n    ],\n    \"mechanism\": {\n      \"type\": \"generic\",\n      \"handled\": true\n    }\n  },\n  \"transaction\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n  \"extra\": {\n    \"session:duration\": 6\n  },\n  \"breadcrumbs\": {\n    \"values\": [\n      {\n        \"timestamp\": 1534257309.996,\n        \"message\": \"_prepareFrames stackInfo: [object Object]\",\n        \"level\": \"log\",\n        \"category\": \"console\"\n      },\n      // ...\n   ]\n  },\n  \"event_id\": \"ea0334adaf9d43b78e72da2b10e084a9\",\n  \"trimHeadFrames\": 0\n}\n```\n\n其中支持的信息类型重点分为以下几种：\n\n* sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息\n* 错误信息，主要包括错误调用栈信息\n* request 信息，主要包括浏览器的 User-Agent、当前请求地址等\n* 面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍\n\n### raven.js 面包屑收集\n\n面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。\n\n面包屑信息主要包括这几类：\n\n* 用户对某个元素的点击或者用户对某个可输入元素的输入\n* 发送的 http 请求\n* console 打印的信息（支持配置 'debug', 'info', 'warn', 'error', 'log' 等不同级别）\n* window.location 变化信息\n\n接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。\n\n实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：\n\n* window.setTimeout\n* window.setInterval\n* window.requestAnimationFrame\n* EventTarget.addEventListener\n* EventTarget.removeEventListener\n* XMLHTTPRequest.open\n* XMLHTTPRequest.send\n* window.fetch\n* History.pushState\n* History.replaceState\n\n>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）\n\n接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：\n\n```javascript\nfunction wrapEventTarget(global) {\n      var proto = _window[global] && _window[global].prototype;\n      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\n        fill(\n          proto,\n          'addEventListener',\n          function(orig) {\n            return function(evtName, fn, capture, secure) {\n              try {\n                if (fn && fn.handleEvent) { //兼容通过 handleEvent 的方式进行绑定事件\n                  fn.handleEvent = self.wrap(\n                    {\n                      mechanism: {\n                        type: 'instrument',\n                        data: {\n                          target: global,\n                          function: 'handleEvent',\n                          handler: (fn && fn.name) || '<anonymous>'\n                        }\n                      }\n                    },\n                    fn.handleEvent\n                  );\n                }\n              } catch (err) {\n              }\n\n              var before, clickHandler, keypressHandler;\n\n              if (\n                autoBreadcrumbs &&\n                autoBreadcrumbs.dom &&\n                (global === 'EventTarget' || global === 'Node')\n              ) {\n                // NOTE: generating multiple handlers per addEventListener invocation, should\n                //       revisit and verify we can just use one (almost certainly)\n                clickHandler = self._breadcrumbEventHandler('click');\n                keypressHandler = self._keypressEventHandler();\n                before = function(evt) { // 钩子函数，用于在回调函数调用的时候记录信息\n                  if (!evt) return;\n\n                  var eventType;\n                  try {\n                    eventType = evt.type;\n                  } catch (e) {\n                    // just accessing event properties can throw an exception in some rare circumstances\n                    // see: https://github.com/getsentry/raven-js/issues/838\n                    return;\n                  }\n                  if (eventType === 'click') return clickHandler(evt);\n                  else if (eventType === 'keypress') return keypressHandler(evt);\n                };\n              }\n              return orig.call(\n                this,\n                evtName,\n                self.wrap(\n                  {\n                    mechanism: {\n                      type: 'instrument',\n                      data: {\n                        target: global,\n                        function: 'addEventListener',\n                        handler: (fn && fn.name) || '<anonymous>'\n                      }\n                    }\n                  },\n                  fn,\n                  before\n                ),\n                capture,\n                secure\n              );\n            };\n          },\n          wrappedBuiltIns\n        );\n        fill(\n          proto,\n          'removeEventListener',\n          function(orig) {\n            return function(evt, fn, capture, secure) {\n              try {\n                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);\n              } catch (e) {\n                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments\n              }\n              return orig.call(this, evt, fn, capture, secure);\n            };\n          },\n          wrappedBuiltIns\n        );\n      }\n    }\n```\n\n以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在[这里](http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/)补充一些相关的知识）。\n\n默认情况下，raven.js 只记录通过 `EventTarget.addEventListener` 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。\n\n### raven.js 如何和框架配合使用\n\nraven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。\n\nraven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。\n\n插件内容本身非常简单，我们可以看一下 vue 插件的代码：\n\n```\nfunction formatComponentName(vm) {\n  if (vm.$root === vm) {\n    return 'root instance';\n  }\n  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n  return (\n    (name ? 'component <' + name + '>' : 'anonymous component') +\n    (vm._isVue && vm.$options.__file ? ' at ' + vm.$options.__file : '')\n  );\n}\n\nfunction vuePlugin(Raven, Vue) {\n  Vue = Vue || window.Vue;\n\n  // quit if Vue isn't on the page\n  if (!Vue || !Vue.config) return;\n\n  var _oldOnError = Vue.config.errorHandler;\n  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) {\n    var metaData = {};\n\n    // vm and lifecycleHook are not always available\n    if (Object.prototype.toString.call(vm) === '[object Object]') {\n      metaData.componentName = formatComponentName(vm);\n      metaData.propsData = vm.$options.propsData;\n    }\n\n    if (typeof info !== 'undefined') {\n      metaData.lifecycleHook = info;\n    }\n\n    Raven.captureException(error, {\n      extra: metaData\n    });\n\n    if (typeof _oldOnError === 'function') {\n      _oldOnError.call(this, error, vm, info);\n    }\n  };\n}\n\nmodule.exports = vuePlugin;\n```\n\n应该不用进行过多解释。\n\n你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了[Error Boundaries](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考[这里](https://docs.sentry.io/clients/javascript/integrations/react/)\n\n>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。\n\n完。\n\n","source":"_posts/从源码分析sentry的错误信息收集.md","raw":"---\ntitle: 从源码分析sentry的错误信息收集\ndate: 2018-08-18 19:23:55\ntags:\n    - javascript\n    - 前端监控\n---\n\nraven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是`https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js`。\n\n首先抛出几个问题：\n\n* **raven.js 是如何收集浏览器错误信息的？**\n* **raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？**\n* **面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？**\n* **raven.js 如何和框架配合使用（比如 vue、react）？**\n\n在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。\n\nraven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：\n\n* [json-stringify-safe](https://github.com/moll/json-stringify-safe) ：一个对 `JSON.stringify` 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。\n\t* 这里面有一个注意点要单独说一下，我们熟知的 `JSON.stringify` , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 `json-stringify-safe` 就是充分利用了这三个参数。\n* [md5](https://github.com/blueimp/JavaScript-MD5)：js 的 md5 函数。\n* [TraceKit](https://github.com/csnover/TraceKit)：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。\n\n除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。\n\n### raven.js 是如何收集错误信息的？\n\n我们知道，在前端收集错误，肯定离不开 `window.onerror` 这个函数，那么我们就从这个函数说起。\n\n实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：\n\n```\nfunction installGlobalHandler() {\n  if (_onErrorHandlerInstalled) { // 一个起到标志作用的全局变量\n    return;\n  }\n  _oldOnerrorHandler = _window.onerror; \n  // _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖\n  // 该 _window 经过兼容，实际上就是 window\n  _window.onerror = traceKitWindowOnError;\n  _onErrorHandlerInstalled = true;\n}\n```\n\n相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：\n\n```\nfunction traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n\t\n\tvar exception = utils.isErrorEvent(ex) ? ex.error : ex;\n\t//...\n    stack = TraceKit.computeStackTrace(exception);\n    notifyHandlers(stack, true);\n    //...\n   \n    //...\n    if (_oldOnerrorHandler) {\n       return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n}\n```\n\n其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。\n\nnotifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：\n\n```\nfunction subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n}\n```\n\n以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。\n\n下面我们对错误处理 raven.js 控制的部分做了一些梳理：\n\n```\n _handleOnErrorStackInfo: function(stackInfo, options) {\n    options.mechanism = options.mechanism || {\n      type: 'onerror',\n      handled: false\n    };\n    // mechanism 和错误统计来源有关\n\n    if (!this._ignoreOnError) {\n      this._handleStackInfo(stackInfo, options);\n    }\n},\n\n_handleStackInfo: function(stackInfo, options) {\n    var frames = this._prepareFrames(stackInfo, options);\n\n    this._triggerEvent('handle', {\n      stackInfo: stackInfo,\n      options: options\n    });\n\n    this._processException(\n      stackInfo.name,\n      stackInfo.message,\n      stackInfo.url,\n      stackInfo.lineno,\n      frames,\n      options\n    );\n},\n\n_processException: function(type, message, fileurl, lineno, frames, options) {\n    // 首先根据 message 信息判断是否是需要忽略的错误类型\n    // 然后判断出错的文件是否在黑名单中或者白名单中\n    // 接下来对错误内容进行必要的整合与转换，构造出 data 对象\n    // 最后调用上报函数\n    this._send(data);\n}\n\n_send: function(data) {\n\t\n\t// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息\n\n\t// 交由 _sendProcessedPayload 进行进一步处理\n\tthis._sendProcessedPayload(data);\n}\n\n_sendProcessedPayload: function(data, callback) {\n\n\t// 对 data 增加一些必要的元信息\n\t// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 \n\t(globalOptions.transport || this._makeRequest).call(this, {\n\t     url: url,\n\t     auth: auth,\n\t     data: data,\n\t     options: globalOptions,\n\t     onSuccess: function success() {\n\t       \n\t     },\n\t     onError: function failure(error) {\n\t       \n\t     }\n\t});\n}    \n\n// 真正发起请求的函数\n_makeRequest: function(opts) {\n\t// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求\n\t// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求\n}\n``` \n\n实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：\n\n* 每个函数只处理一件或者一些事情，保持函数的短小整洁。\n* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `try {\n    doSomething(a[0])\n} catch(e) {\n    Raven.captureException(e)\n}` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。\n\n但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：\n\n* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。\n* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `_processException `、`_sendProcessedPayload `、`_makeRequest `等都只在一个链路中被调用一次。\n* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。\n\n最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：\n\n```javascript\nRaven.config('http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2').install()\nlet s = window.ss;\n\ntry{\n    let b = s.b\n} catch (e) {\n    Raven.captureException(e)\n    // sentry should report error now\n}\n\ns.nomethod();\n// sentry should report error now\n```\n\n以上例子中，sentry 会发送两个 POST 请求。\n\n### raven.js 最终上报数据的格式\n\n\n这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。\n\n我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：\n\n```\n{\n  \"project\": \"2\",\n  \"logger\": \"javascript\",\n  \"platform\": \"javascript\",\n  \"request\": {\n    \"headers\": {\n      \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"\n    },\n    \"url\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"\n  },\n  \"exception\": {\n    \"values\": [\n      {\n        \"type\": \"TypeError\",\n        \"value\": \"Cannot read property 'b' of undefined\",\n        \"stacktrace\": {\n          \"frames\": [\n            {\n              \"filename\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n              \"lineno\": 19,\n              \"colno\": 19,\n              \"function\": \"?\",\n              \"in_app\": true\n            }\n          ]\n        }\n      }\n    ],\n    \"mechanism\": {\n      \"type\": \"generic\",\n      \"handled\": true\n    }\n  },\n  \"transaction\": \"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\",\n  \"extra\": {\n    \"session:duration\": 6\n  },\n  \"breadcrumbs\": {\n    \"values\": [\n      {\n        \"timestamp\": 1534257309.996,\n        \"message\": \"_prepareFrames stackInfo: [object Object]\",\n        \"level\": \"log\",\n        \"category\": \"console\"\n      },\n      // ...\n   ]\n  },\n  \"event_id\": \"ea0334adaf9d43b78e72da2b10e084a9\",\n  \"trimHeadFrames\": 0\n}\n```\n\n其中支持的信息类型重点分为以下几种：\n\n* sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息\n* 错误信息，主要包括错误调用栈信息\n* request 信息，主要包括浏览器的 User-Agent、当前请求地址等\n* 面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍\n\n### raven.js 面包屑收集\n\n面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。\n\n面包屑信息主要包括这几类：\n\n* 用户对某个元素的点击或者用户对某个可输入元素的输入\n* 发送的 http 请求\n* console 打印的信息（支持配置 'debug', 'info', 'warn', 'error', 'log' 等不同级别）\n* window.location 变化信息\n\n接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。\n\n实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：\n\n* window.setTimeout\n* window.setInterval\n* window.requestAnimationFrame\n* EventTarget.addEventListener\n* EventTarget.removeEventListener\n* XMLHTTPRequest.open\n* XMLHTTPRequest.send\n* window.fetch\n* History.pushState\n* History.replaceState\n\n>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）\n\n接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：\n\n```javascript\nfunction wrapEventTarget(global) {\n      var proto = _window[global] && _window[global].prototype;\n      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {\n        fill(\n          proto,\n          'addEventListener',\n          function(orig) {\n            return function(evtName, fn, capture, secure) {\n              try {\n                if (fn && fn.handleEvent) { //兼容通过 handleEvent 的方式进行绑定事件\n                  fn.handleEvent = self.wrap(\n                    {\n                      mechanism: {\n                        type: 'instrument',\n                        data: {\n                          target: global,\n                          function: 'handleEvent',\n                          handler: (fn && fn.name) || '<anonymous>'\n                        }\n                      }\n                    },\n                    fn.handleEvent\n                  );\n                }\n              } catch (err) {\n              }\n\n              var before, clickHandler, keypressHandler;\n\n              if (\n                autoBreadcrumbs &&\n                autoBreadcrumbs.dom &&\n                (global === 'EventTarget' || global === 'Node')\n              ) {\n                // NOTE: generating multiple handlers per addEventListener invocation, should\n                //       revisit and verify we can just use one (almost certainly)\n                clickHandler = self._breadcrumbEventHandler('click');\n                keypressHandler = self._keypressEventHandler();\n                before = function(evt) { // 钩子函数，用于在回调函数调用的时候记录信息\n                  if (!evt) return;\n\n                  var eventType;\n                  try {\n                    eventType = evt.type;\n                  } catch (e) {\n                    // just accessing event properties can throw an exception in some rare circumstances\n                    // see: https://github.com/getsentry/raven-js/issues/838\n                    return;\n                  }\n                  if (eventType === 'click') return clickHandler(evt);\n                  else if (eventType === 'keypress') return keypressHandler(evt);\n                };\n              }\n              return orig.call(\n                this,\n                evtName,\n                self.wrap(\n                  {\n                    mechanism: {\n                      type: 'instrument',\n                      data: {\n                        target: global,\n                        function: 'addEventListener',\n                        handler: (fn && fn.name) || '<anonymous>'\n                      }\n                    }\n                  },\n                  fn,\n                  before\n                ),\n                capture,\n                secure\n              );\n            };\n          },\n          wrappedBuiltIns\n        );\n        fill(\n          proto,\n          'removeEventListener',\n          function(orig) {\n            return function(evt, fn, capture, secure) {\n              try {\n                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);\n              } catch (e) {\n                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments\n              }\n              return orig.call(this, evt, fn, capture, secure);\n            };\n          },\n          wrappedBuiltIns\n        );\n      }\n    }\n```\n\n以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在[这里](http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/)补充一些相关的知识）。\n\n默认情况下，raven.js 只记录通过 `EventTarget.addEventListener` 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。\n\n### raven.js 如何和框架配合使用\n\nraven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。\n\nraven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。\n\n插件内容本身非常简单，我们可以看一下 vue 插件的代码：\n\n```\nfunction formatComponentName(vm) {\n  if (vm.$root === vm) {\n    return 'root instance';\n  }\n  var name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n  return (\n    (name ? 'component <' + name + '>' : 'anonymous component') +\n    (vm._isVue && vm.$options.__file ? ' at ' + vm.$options.__file : '')\n  );\n}\n\nfunction vuePlugin(Raven, Vue) {\n  Vue = Vue || window.Vue;\n\n  // quit if Vue isn't on the page\n  if (!Vue || !Vue.config) return;\n\n  var _oldOnError = Vue.config.errorHandler;\n  Vue.config.errorHandler = function VueErrorHandler(error, vm, info) {\n    var metaData = {};\n\n    // vm and lifecycleHook are not always available\n    if (Object.prototype.toString.call(vm) === '[object Object]') {\n      metaData.componentName = formatComponentName(vm);\n      metaData.propsData = vm.$options.propsData;\n    }\n\n    if (typeof info !== 'undefined') {\n      metaData.lifecycleHook = info;\n    }\n\n    Raven.captureException(error, {\n      extra: metaData\n    });\n\n    if (typeof _oldOnError === 'function') {\n      _oldOnError.call(this, error, vm, info);\n    }\n  };\n}\n\nmodule.exports = vuePlugin;\n```\n\n应该不用进行过多解释。\n\n你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了[Error Boundaries](https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考[这里](https://docs.sentry.io/clients/javascript/integrations/react/)\n\n>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。\n\n完。\n\n","slug":"从源码分析sentry的错误信息收集","published":1,"updated":"2020-02-17T12:50:55.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6nw00018zomo3dbodjq","content":"<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p>\n<p>首先抛出几个问题：</p>\n<ul>\n<li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li>\n<li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li>\n<li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li>\n<li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li>\n</ul>\n<p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p>\n<p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p>\n<ul>\n<li><a href=\"https://github.com/moll/json-stringify-safe\" target=\"_blank\" rel=\"noopener\">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul>\n<li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/blueimp/JavaScript-MD5\" target=\"_blank\" rel=\"noopener\">md5</a>：js 的 md5 函数。</li>\n<li><a href=\"https://github.com/csnover/TraceKit\" target=\"_blank\" rel=\"noopener\">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li>\n</ul>\n<p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p>\n<h3 id=\"raven-js-是如何收集错误信息的？\"><a href=\"#raven-js-是如何收集错误信息的？\" class=\"headerlink\" title=\"raven.js 是如何收集错误信息的？\"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p>\n<p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function installGlobalHandler() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable\">_onErrorHandlerInstalled</span>) &#123; <span class=\"comment\">// 一个起到标志作用的全局变量</span></span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable\">_oldOnerrorHandler</span> = <span class=\"variable\">_window</span>.onerror; </span><br><span class=\"line\">  <span class=\"comment\">// _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span></span><br><span class=\"line\">  <span class=\"comment\">// 该 _window 经过兼容，实际上就是 window</span></span><br><span class=\"line\">  <span class=\"variable\">_window</span>.onerror = traceKitWindowOnError;</span><br><span class=\"line\">  <span class=\"variable\">_onErrorHandlerInstalled</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traceKitWindowOnError</span>(<span class=\"params\">msg, url, lineNo, colNo, ex</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> exception = utils.isErrorEvent(ex) ? ex.error : ex;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    stack = TraceKit.computeStackTrace(exception);</span><br><span class=\"line\">    notifyHandlers(stack, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_oldOnerrorHandler) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> _oldOnerrorHandler.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p>\n<p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span><span class=\"params\">(handler)</span> </span>&#123;</span><br><span class=\"line\">    installGlobalHandler();</span><br><span class=\"line\">    handlers.push(handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p>\n<p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> _handleOnErrorStackInfo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    options.mechanism = options.mechanism || &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'onerror'</span>,</span><br><span class=\"line\">      handled: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// mechanism 和错误统计来源有关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._ignoreOnError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._handleStackInfo(stackInfo, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">_handleStackInfo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> frames = <span class=\"keyword\">this</span>._prepareFrames(stackInfo, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._triggerEvent(<span class=\"string\">'handle'</span>, &#123;</span><br><span class=\"line\">      stackInfo: stackInfo,</span><br><span class=\"line\">      options: options</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._processException(</span><br><span class=\"line\">      stackInfo.name,</span><br><span class=\"line\">      stackInfo.message,</span><br><span class=\"line\">      stackInfo.url,</span><br><span class=\"line\">      stackInfo.lineno,</span><br><span class=\"line\">      frames,</span><br><span class=\"line\">      options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">_processException: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, message, fileurl, lineno, frames, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先根据 message 信息判断是否是需要忽略的错误类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后判断出错的文件是否在黑名单中或者白名单中</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后调用上报函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._send(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_send: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 交由 _sendProcessedPayload 进行进一步处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._sendProcessedPayload(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_sendProcessedPayload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 增加一些必要的元信息</span></span><br><span class=\"line\">\t<span class=\"comment\">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span></span><br><span class=\"line\">\t(globalOptions.transport || <span class=\"keyword\">this</span>._makeRequest).call(<span class=\"keyword\">this</span>, &#123;</span><br><span class=\"line\">\t     url: url,</span><br><span class=\"line\">\t     auth: auth,</span><br><span class=\"line\">\t     data: data,</span><br><span class=\"line\">\t     options: globalOptions,</span><br><span class=\"line\">\t     onSuccess: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">success</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;,</span><br><span class=\"line\">\t     onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failure</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 真正发起请求的函数</span></span><br><span class=\"line\">_makeRequest: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 每个函数只处理一件或者一些事情，保持函数的短小整洁。</span></span><br><span class=\"line\"><span class=\"string\">* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `</span><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doSomething(a[<span class=\"number\">0</span>])</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">&#125;<span class=\"string\">` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</span></span><br><span class=\"line\"><span class=\"string\">* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `</span>_processException <span class=\"string\">`、`</span>_sendProcessedPayload <span class=\"string\">`、`</span>_makeRequest <span class=\"string\">`等都只在一个链路中被调用一次。</span></span><br><span class=\"line\"><span class=\"string\">* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">Raven.config(<span class=\"string\">'http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2'</span>).install()</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">window</span>.ss;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = s.b</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">    <span class=\"comment\">// sentry should report error now</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.nomethod();</span><br><span class=\"line\"><span class=\"comment\">// sentry should report error now</span></span><br></pre></td></tr></table></figure>\n<p>以上例子中，sentry 会发送两个 POST 请求。</p>\n<h3 id=\"raven-js-最终上报数据的格式\"><a href=\"#raven-js-最终上报数据的格式\" class=\"headerlink\" title=\"raven.js 最终上报数据的格式\"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p>\n<p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"project\"</span>: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"logger\"</span>: <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"platform\"</span>: <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"request\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"User-Agent\"</span>: <span class=\"string\">\"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"exception\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"values\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"TypeError\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"Cannot read property 'b' of undefined\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"stacktrace\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"frames\"</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"filename\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"lineno\"</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"colno\"</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"function\"</span>: <span class=\"string\">\"?\"</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"in_app\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"mechanism\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"generic\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"handled\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"transaction\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"extra\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"session:duration\"</span>: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"breadcrumbs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"values\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"timestamp\"</span>: <span class=\"number\">1534257309.996</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"message\"</span>: <span class=\"string\">\"_prepareFrames stackInfo: [object Object]\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"level\"</span>: <span class=\"string\">\"log\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"category\"</span>: <span class=\"string\">\"console\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"event_id\"</span>: <span class=\"string\">\"ea0334adaf9d43b78e72da2b10e084a9\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"trimHeadFrames\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中支持的信息类型重点分为以下几种：</p>\n<ul>\n<li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li>\n<li>错误信息，主要包括错误调用栈信息</li>\n<li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li>\n<li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li>\n</ul>\n<h3 id=\"raven-js-面包屑收集\"><a href=\"#raven-js-面包屑收集\" class=\"headerlink\" title=\"raven.js 面包屑收集\"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p>\n<p>面包屑信息主要包括这几类：</p>\n<ul>\n<li>用户对某个元素的点击或者用户对某个可输入元素的输入</li>\n<li>发送的 http 请求</li>\n<li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li>\n<li>window.location 变化信息</li>\n</ul>\n<p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p>\n<p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p>\n<ul>\n<li>window.setTimeout</li>\n<li>window.setInterval</li>\n<li>window.requestAnimationFrame</li>\n<li>EventTarget.addEventListener</li>\n<li>EventTarget.removeEventListener</li>\n<li>XMLHTTPRequest.open</li>\n<li>XMLHTTPRequest.send</li>\n<li>window.fetch</li>\n<li>History.pushState</li>\n<li>History.replaceState</li>\n</ul>\n<blockquote>\n<p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p>\n</blockquote>\n<p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapEventTarget</span>(<span class=\"params\">global</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> proto = _window[global] &amp;&amp; _window[global].prototype;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class=\"string\">'addEventListener'</span>)) &#123;</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">'addEventListener'</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class=\"comment\">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class=\"line\">                  fn.handleEvent = self.wrap(</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      mechanism: &#123;</span><br><span class=\"line\">                        type: <span class=\"string\">'instrument'</span>,</span><br><span class=\"line\">                        data: &#123;</span><br><span class=\"line\">                          target: global,</span><br><span class=\"line\">                          <span class=\"function\"><span class=\"keyword\">function</span>: '<span class=\"title\">handleEvent</span>',</span></span><br><span class=\"line\"><span class=\"function\">                          <span class=\"title\">handler</span>: (<span class=\"params\">fn &amp;&amp; fn.name</span>) || '&lt;<span class=\"title\">anonymous</span>&gt;'</span></span><br><span class=\"line\"><span class=\"function\">                        &#125;</span></span><br><span class=\"line\"><span class=\"function\">                      &#125;</span></span><br><span class=\"line\"><span class=\"function\">                    &#125;,</span></span><br><span class=\"line\"><span class=\"function\">                    <span class=\"title\">fn</span>.<span class=\"title\">handleEvent</span></span></span><br><span class=\"line\"><span class=\"function\">                  );</span></span><br><span class=\"line\"><span class=\"function\">                &#125;</span></span><br><span class=\"line\"><span class=\"function\">              &#125; <span class=\"title\">catch</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">var</span> before, clickHandler, keypressHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                autoBreadcrumbs &amp;&amp;</span><br><span class=\"line\">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class=\"line\">                (global === <span class=\"string\">'EventTarget'</span> || global === <span class=\"string\">'Node'</span>)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class=\"line\">                <span class=\"comment\">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class=\"line\">                clickHandler = self._breadcrumbEventHandler(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">                keypressHandler = self._keypressEventHandler();</span><br><span class=\"line\">                before = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123; <span class=\"comment\">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!evt) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">var</span> eventType;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    eventType = evt.type;</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class=\"line\">                    <span class=\"comment\">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (eventType === <span class=\"string\">'click'</span>) <span class=\"keyword\">return</span> clickHandler(evt);</span><br><span class=\"line\">                  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType === <span class=\"string\">'keypress'</span>) <span class=\"keyword\">return</span> keypressHandler(evt);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                evtName,</span><br><span class=\"line\">                self.wrap(</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    mechanism: &#123;</span><br><span class=\"line\">                      type: <span class=\"string\">'instrument'</span>,</span><br><span class=\"line\">                      data: &#123;</span><br><span class=\"line\">                        target: global,</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">function</span>: '<span class=\"title\">addEventListener</span>',</span></span><br><span class=\"line\"><span class=\"function\">                        <span class=\"title\">handler</span>: (<span class=\"params\">fn &amp;&amp; fn.name</span>) || '&lt;<span class=\"title\">anonymous</span>&gt;'</span></span><br><span class=\"line\"><span class=\"function\">                      &#125;</span></span><br><span class=\"line\"><span class=\"function\">                    &#125;</span></span><br><span class=\"line\"><span class=\"function\">                  &#125;,</span></span><br><span class=\"line\"><span class=\"function\">                  <span class=\"title\">fn</span>,</span></span><br><span class=\"line\"><span class=\"function\">                  <span class=\"title\">before</span></span></span><br><span class=\"line\"><span class=\"function\">                ),</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">capture</span>,</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">secure</span></span></span><br><span class=\"line\"><span class=\"function\">              );</span></span><br><span class=\"line\"><span class=\"function\">            &#125;;</span></span><br><span class=\"line\"><span class=\"function\">          &#125;,</span></span><br><span class=\"line\"><span class=\"function\">          <span class=\"title\">wrappedBuiltIns</span></span></span><br><span class=\"line\"><span class=\"function\">        );</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">fill</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          proto,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"string\">'removeEventListener'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          function(orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(<span class=\"keyword\">this</span>, evt, fn, capture, secure);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href=\"http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/\" target=\"_blank\" rel=\"noopener\">这里</a>补充一些相关的知识）。</p>\n<p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p>\n<h3 id=\"raven-js-如何和框架配合使用\"><a href=\"#raven-js-如何和框架配合使用\" class=\"headerlink\" title=\"raven.js 如何和框架配合使用\"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p>\n<p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p>\n<p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatComponentName</span>(<span class=\"params\">vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.$root === vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'root instance'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    (name ? <span class=\"string\">'component &lt;'</span> + name + <span class=\"string\">'&gt;'</span> : <span class=\"string\">'anonymous component'</span>) +</span><br><span class=\"line\">    (vm._isVue &amp;&amp; vm.$options.__file ? <span class=\"string\">' at '</span> + vm.$options.__file : <span class=\"string\">''</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuePlugin</span>(<span class=\"params\">Raven, Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue = Vue || <span class=\"built_in\">window</span>.Vue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// quit if Vue isn't on the page</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Vue || !Vue.config) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _oldOnError = Vue.config.errorHandler;</span><br><span class=\"line\">  Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">VueErrorHandler</span>(<span class=\"params\">error, vm, info</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> metaData = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vm and lifecycleHook are not always available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(vm) === <span class=\"string\">'[object Object]'</span>) &#123;</span><br><span class=\"line\">      metaData.componentName = formatComponentName(vm);</span><br><span class=\"line\">      metaData.propsData = vm.$options.propsData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> info !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      metaData.lifecycleHook = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Raven.captureException(error, &#123;</span><br><span class=\"line\">      extra: metaData</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> _oldOnError === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      _oldOnError.call(<span class=\"keyword\">this</span>, error, vm, info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = vuePlugin;</span><br></pre></td></tr></table></figure>\n<p>应该不用进行过多解释。</p>\n<p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href=\"https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html\" target=\"_blank\" rel=\"noopener\">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href=\"https://docs.sentry.io/clients/javascript/integrations/react/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<blockquote>\n<p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p>\n</blockquote>\n<p>完。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>raven.js 是 sentry 为 JavaScript 错误上报提供的 JS-SDK，本篇我们基于其源代码对其原理进行分析，本篇文章只分析前端部分，对应的文件目录是<code>https://github.com/getsentry/sentry-javascript/tree/master/packages/raven-js</code>。</p>\n<p>首先抛出几个问题：</p>\n<ul>\n<li><strong>raven.js 是如何收集浏览器错误信息的？</strong></li>\n<li><strong>raven.js 上报的错误信息格式是什么样的？又是如何把这些信息传给后端？支不支持合并上报？</strong></li>\n<li><strong>面包屑（breadcrumbs）是什么？raven.js 如何来收集面包屑信息？</strong></li>\n<li><strong>raven.js 如何和框架配合使用（比如 vue、react）？</strong></li>\n</ul>\n<p>在回答以上这几个问题之前，我们首先来对 raven.js 做一个宏观的分析，主要涉及其文件目录、所引用的第三方框架等。</p>\n<p>raven.js 的核心文件内容并不多，其中使用了三个第三方库，放在了 vendor 文件夹下：</p>\n<ul>\n<li><a href=\"https://github.com/moll/json-stringify-safe\" target=\"_blank\" rel=\"noopener\">json-stringify-safe</a> ：一个对 <code>JSON.stringify</code> 的封装，安全的 json 序列化操作函数，不会抛出循环引用的错误。<ul>\n<li>这里面有一个注意点要单独说一下，我们熟知的 <code>JSON.stringify</code> , 可以接受三个参数：第一个参数是我们要序列化的对象；第二个参数是对其中键值对的处理函数；第三个参数是控制缩进空格。reven.js 的 <code>json-stringify-safe</code> 就是充分利用了这三个参数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/blueimp/JavaScript-MD5\" target=\"_blank\" rel=\"noopener\">md5</a>：js 的 md5 函数。</li>\n<li><a href=\"https://github.com/csnover/TraceKit\" target=\"_blank\" rel=\"noopener\">TraceKit</a>：TraceKit 是一个已经比较完善的错误收集、堆栈格式化的库，reven.js 的功能在很大程度上对它有所依赖。</li>\n</ul>\n<p>除此之外，raven.js 支持插件，官方提供的一些知名库的 sentry 插件主要放在了 plugin 文件夹下面，raven.js 的一些核心文件，则放在了 src 文件夹下面。</p>\n<h3 id=\"raven-js-是如何收集错误信息的？\"><a href=\"#raven-js-是如何收集错误信息的？\" class=\"headerlink\" title=\"raven.js 是如何收集错误信息的？\"></a>raven.js 是如何收集错误信息的？</h3><p>我们知道，在前端收集错误，肯定离不开 <code>window.onerror</code> 这个函数，那么我们就从这个函数说起。</p>\n<p>实际上，这部分工作是 raven.js 引用的第三方库 TraceKit 完成的：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function installGlobalHandler() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable\">_onErrorHandlerInstalled</span>) &#123; <span class=\"comment\">// 一个起到标志作用的全局变量</span></span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable\">_oldOnerrorHandler</span> = <span class=\"variable\">_window</span>.onerror; </span><br><span class=\"line\">  <span class=\"comment\">// _oldOnerrorHandler 是防止对用户其他地方定义的回调函数进行覆盖</span></span><br><span class=\"line\">  <span class=\"comment\">// 该 _window 经过兼容，实际上就是 window</span></span><br><span class=\"line\">  <span class=\"variable\">_window</span>.onerror = traceKitWindowOnError;</span><br><span class=\"line\">  <span class=\"variable\">_onErrorHandlerInstalled</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相关错误回调函数交给 traceKitWindowOnError 处理，下面我们来看一下 traceKitWindowOnError 函数，为了避免太多冗余代码，我们仅分析一种主要情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traceKitWindowOnError</span>(<span class=\"params\">msg, url, lineNo, colNo, ex</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> exception = utils.isErrorEvent(ex) ? ex.error : ex;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    stack = TraceKit.computeStackTrace(exception);</span><br><span class=\"line\">    notifyHandlers(stack, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_oldOnerrorHandler) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> _oldOnerrorHandler.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中调用的最重要的一个函数，就是 computeStackTrace，而这个函数也是 TraceKit 的核心函数，简单来讲，它做的事情就是统一格式化报错信息调用栈，因为对于各个浏览器来说，返回的 Error 调用栈信息格式不尽相同，另外甚至还有的浏览器并不返回调用栈，computeStackTrace 函数对这些情况都做了兼容性处理，并且对于一些不返回调用栈的情况，还使用了 caller 来向上回溯函数的调用栈，最终把报错信息转化成一个键相同的对象数组，做到了报错信息格式的统一。</p>\n<p>notifyHandlers 函数则是通知相关的回调函数。 实际上，raven.js 在 install 函数中会调用 TraceKit.report.subscribe 函数，并把对错误的处理逻辑写入回调：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span><span class=\"params\">(handler)</span> </span>&#123;</span><br><span class=\"line\">    installGlobalHandler();</span><br><span class=\"line\">    handlers.push(handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上过程完成了错误处理过程中的负责角色转换，并且借助 TraceKit，可以使 raven.js 得到一个结构比较清晰的带有格式化好的调用栈信息的错误内容对象，之后，raven.js 对错误内容进一步处理并最终上报。</p>\n<p>下面我们对错误处理 raven.js 控制的部分做了一些梳理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> _handleOnErrorStackInfo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    options.mechanism = options.mechanism || &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'onerror'</span>,</span><br><span class=\"line\">      handled: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// mechanism 和错误统计来源有关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._ignoreOnError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._handleStackInfo(stackInfo, options);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">_handleStackInfo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">stackInfo, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> frames = <span class=\"keyword\">this</span>._prepareFrames(stackInfo, options);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._triggerEvent(<span class=\"string\">'handle'</span>, &#123;</span><br><span class=\"line\">      stackInfo: stackInfo,</span><br><span class=\"line\">      options: options</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._processException(</span><br><span class=\"line\">      stackInfo.name,</span><br><span class=\"line\">      stackInfo.message,</span><br><span class=\"line\">      stackInfo.url,</span><br><span class=\"line\">      stackInfo.lineno,</span><br><span class=\"line\">      frames,</span><br><span class=\"line\">      options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">_processException: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type, message, fileurl, lineno, frames, options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先根据 message 信息判断是否是需要忽略的错误类型</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后判断出错的文件是否在黑名单中或者白名单中</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来对错误内容进行必要的整合与转换，构造出 data 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后调用上报函数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>._send(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_send: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 进一步处理，增加必要的信息，包括后续会提到的面包屑信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 交由 _sendProcessedPayload 进行进一步处理</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>._sendProcessedPayload(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_sendProcessedPayload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 对 data 增加一些必要的元信息</span></span><br><span class=\"line\">\t<span class=\"comment\">// 可以通过自定义 globalOptions.transport 的方式来自定义上报函数 </span></span><br><span class=\"line\">\t(globalOptions.transport || <span class=\"keyword\">this</span>._makeRequest).call(<span class=\"keyword\">this</span>, &#123;</span><br><span class=\"line\">\t     url: url,</span><br><span class=\"line\">\t     auth: auth,</span><br><span class=\"line\">\t     data: data,</span><br><span class=\"line\">\t     options: globalOptions,</span><br><span class=\"line\">\t     onSuccess: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">success</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;,</span><br><span class=\"line\">\t     onError: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failure</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">\t       </span><br><span class=\"line\">\t     &#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 真正发起请求的函数</span></span><br><span class=\"line\">_makeRequest: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 对于支持 fetch 的浏览器，直接使用 fetch 的方式发送 POST 请求</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果浏览器不支持 fetch，则使用 XHR 的传统方式发送 POST 请求</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">实际上我们可以发现，从拿到已经初步格式化的报错信息，到最终真正执行数据上报，raven.js 的过程非常漫长，这其中我分析有如下几个原因：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 每个函数只处理一件或者一些事情，保持函数的短小整洁。</span></span><br><span class=\"line\"><span class=\"string\">* 部分函数可以做到复用（因为除了自动捕获错误的方式， raven.js 还提供通过 captureException，即 `</span><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doSomething(a[<span class=\"number\">0</span>])</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">&#125;<span class=\"string\">` 的方式来上报错误，两个过程中有一些函数的调用是有重叠的）。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">但是笔者认为，raven.js 的代码设计还有很多值得优化的地方，比如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 对最终上报数据（data）的属性处理和增加分散在多个函数，并且有较多可选项目，很难梳理出一个完整的 data 格式，并且不便于维护。</span></span><br><span class=\"line\"><span class=\"string\">* 部分函数的拆分必要性不足，并且会增加链路的复杂性，比如 `</span>_processException <span class=\"string\">`、`</span>_sendProcessedPayload <span class=\"string\">`、`</span>_makeRequest <span class=\"string\">`等都只在一个链路中被调用一次。</span></span><br><span class=\"line\"><span class=\"string\">* 部分属性重命名会造成资源浪费，由于 TraceKit 部分最终返回的数据格式并不完全满足 raven.js 的需要，所以 raven.js 之后又在较后阶段进行了重命名等处理，实际上这些内容完全可以通过一些其他的方式避免。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">最后，非常遗憾，sentry 目前完全不支持合并上报，就算是在同一个事件循环（甚至事件循环的同一个阶段，关于事件循环，可以参考我之前绘制的[一张图](https://www.processon.com/view/link/5b6ec8cbe4b053a09c2fb977)）的两个错误，sentry 都是分开来上报的，这里有一个简单例子：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">Raven.config(<span class=\"string\">'http://8ec3f1a9f652463bb58191bd0b35f20c@localhost:9000/2'</span>).install()</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"built_in\">window</span>.ss;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = s.b</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    Raven.captureException(e)</span><br><span class=\"line\">    <span class=\"comment\">// sentry should report error now</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">s.nomethod();</span><br><span class=\"line\"><span class=\"comment\">// sentry should report error now</span></span><br></pre></td></tr></table></figure>\n<p>以上例子中，sentry 会发送两个 POST 请求。</p>\n<h3 id=\"raven-js-最终上报数据的格式\"><a href=\"#raven-js-最终上报数据的格式\" class=\"headerlink\" title=\"raven.js 最终上报数据的格式\"></a>raven.js 最终上报数据的格式</h3><p>这一部分，我们并不会详细地分析 raven.js 上报的数据的每一项内容，仅会给读者展示一个比较典型的情况。</p>\n<p>我们看一下对于一个一般的 js 错误，raven.js 上报的 json 中包含哪些内容，下面是一个已经删掉一些冗余内容的典型上报信息：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"project\"</span>: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"logger\"</span>: <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"platform\"</span>: <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"request\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"headers\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"User-Agent\"</span>: <span class=\"string\">\"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"url\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"exception\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"values\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"TypeError\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"Cannot read property 'b' of undefined\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"stacktrace\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">\"frames\"</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"attr\">\"filename\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"lineno\"</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"colno\"</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"function\"</span>: <span class=\"string\">\"?\"</span>,</span><br><span class=\"line\">              <span class=\"attr\">\"in_app\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"mechanism\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"generic\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"handled\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"transaction\"</span>: <span class=\"string\">\"http://localhost:63342/sentry-test1/test1.html?_ijt=j54dmgn136gom08n8v8v9fdddu\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"extra\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"session:duration\"</span>: <span class=\"number\">6</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"breadcrumbs\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"values\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"timestamp\"</span>: <span class=\"number\">1534257309.996</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"message\"</span>: <span class=\"string\">\"_prepareFrames stackInfo: [object Object]\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"level\"</span>: <span class=\"string\">\"log\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"category\"</span>: <span class=\"string\">\"console\"</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      // ...</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"event_id\"</span>: <span class=\"string\">\"ea0334adaf9d43b78e72da2b10e084a9\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"trimHeadFrames\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中支持的信息类型重点分为以下几种：</p>\n<ul>\n<li>sentry 基本配置信息，包括库本身的配置和使用者的配置信息，以及用户的一些自定义信息</li>\n<li>错误信息，主要包括错误调用栈信息</li>\n<li>request 信息，主要包括浏览器的 User-Agent、当前请求地址等</li>\n<li>面包屑信息，关于面包屑具体指的是什么，我们会在下一环节进行介绍</li>\n</ul>\n<h3 id=\"raven-js-面包屑收集\"><a href=\"#raven-js-面包屑收集\" class=\"headerlink\" title=\"raven.js 面包屑收集\"></a>raven.js 面包屑收集</h3><p>面包屑信息，也就是错误在发生之前，一些用户、浏览器的行为信息，raven.js 实现了一个简单的队列（有一个最大条目长度，默认为 100），这个队列在时刻记录着这些信息，一旦错误发生并且需要上报，raven.js 就把这个队列的信息内容，作为面包屑 breadcrumbs，发回客户端。</p>\n<p>面包屑信息主要包括这几类：</p>\n<ul>\n<li>用户对某个元素的点击或者用户对某个可输入元素的输入</li>\n<li>发送的 http 请求</li>\n<li>console 打印的信息（支持配置 ‘debug’, ‘info’, ‘warn’, ‘error’, ‘log’ 等不同级别）</li>\n<li>window.location 变化信息</li>\n</ul>\n<p>接下来，我们对这几类面包屑信息 sentry 的记录实现进行简单的分析。</p>\n<p>实际上，sentry 对这些信息记录的方式比较一致，都是通过对原声的函数进行包装，并且在包装好的函数中增加自己的钩子函数，来实现触发时候的事件记录，实际上，sentry 总共包装的函数有：</p>\n<ul>\n<li>window.setTimeout</li>\n<li>window.setInterval</li>\n<li>window.requestAnimationFrame</li>\n<li>EventTarget.addEventListener</li>\n<li>EventTarget.removeEventListener</li>\n<li>XMLHTTPRequest.open</li>\n<li>XMLHTTPRequest.send</li>\n<li>window.fetch</li>\n<li>History.pushState</li>\n<li>History.replaceState</li>\n</ul>\n<blockquote>\n<p>备注：这里包装的所有函数，其中有一部分只是使 raven.js 具有捕获回调函数中错误的能力（对回调函数进行包装）</p>\n</blockquote>\n<p>接下来我们看一段典型的代码，来分析 raven.js 是如何记录用户的点击和输入信息的（通过对 EventTarget.addEventListener 进行封装）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapEventTarget</span>(<span class=\"params\">global</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> proto = _window[global] &amp;&amp; _window[global].prototype;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (proto &amp;&amp; proto.hasOwnProperty &amp;&amp; proto.hasOwnProperty(<span class=\"string\">'addEventListener'</span>)) &#123;</span><br><span class=\"line\">        fill(</span><br><span class=\"line\">          proto,</span><br><span class=\"line\">          <span class=\"string\">'addEventListener'</span>,</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evtName, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fn &amp;&amp; fn.handleEvent) &#123; <span class=\"comment\">//兼容通过 handleEvent 的方式进行绑定事件</span></span><br><span class=\"line\">                  fn.handleEvent = self.wrap(</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      mechanism: &#123;</span><br><span class=\"line\">                        type: <span class=\"string\">'instrument'</span>,</span><br><span class=\"line\">                        data: &#123;</span><br><span class=\"line\">                          target: global,</span><br><span class=\"line\">                          <span class=\"function\"><span class=\"keyword\">function</span>: '<span class=\"title\">handleEvent</span>',</span></span><br><span class=\"line\"><span class=\"function\">                          <span class=\"title\">handler</span>: (<span class=\"params\">fn &amp;&amp; fn.name</span>) || '&lt;<span class=\"title\">anonymous</span>&gt;'</span></span><br><span class=\"line\"><span class=\"function\">                        &#125;</span></span><br><span class=\"line\"><span class=\"function\">                      &#125;</span></span><br><span class=\"line\"><span class=\"function\">                    &#125;,</span></span><br><span class=\"line\"><span class=\"function\">                    <span class=\"title\">fn</span>.<span class=\"title\">handleEvent</span></span></span><br><span class=\"line\"><span class=\"function\">                  );</span></span><br><span class=\"line\"><span class=\"function\">                &#125;</span></span><br><span class=\"line\"><span class=\"function\">              &#125; <span class=\"title\">catch</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">var</span> before, clickHandler, keypressHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (</span><br><span class=\"line\">                autoBreadcrumbs &amp;&amp;</span><br><span class=\"line\">                autoBreadcrumbs.dom &amp;&amp;</span><br><span class=\"line\">                (global === <span class=\"string\">'EventTarget'</span> || global === <span class=\"string\">'Node'</span>)</span><br><span class=\"line\">              ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> generating multiple handlers per addEventListener invocation, should</span></span><br><span class=\"line\">                <span class=\"comment\">//       revisit and verify we can just use one (almost certainly)</span></span><br><span class=\"line\">                clickHandler = self._breadcrumbEventHandler(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">                keypressHandler = self._keypressEventHandler();</span><br><span class=\"line\">                before = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123; <span class=\"comment\">// 钩子函数，用于在回调函数调用的时候记录信息</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!evt) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"keyword\">var</span> eventType;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    eventType = evt.type;</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// just accessing event properties can throw an exception in some rare circumstances</span></span><br><span class=\"line\">                    <span class=\"comment\">// see: https://github.com/getsentry/raven-js/issues/838</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (eventType === <span class=\"string\">'click'</span>) <span class=\"keyword\">return</span> clickHandler(evt);</span><br><span class=\"line\">                  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eventType === <span class=\"string\">'keypress'</span>) <span class=\"keyword\">return</span> keypressHandler(evt);</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                evtName,</span><br><span class=\"line\">                self.wrap(</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    mechanism: &#123;</span><br><span class=\"line\">                      type: <span class=\"string\">'instrument'</span>,</span><br><span class=\"line\">                      data: &#123;</span><br><span class=\"line\">                        target: global,</span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">function</span>: '<span class=\"title\">addEventListener</span>',</span></span><br><span class=\"line\"><span class=\"function\">                        <span class=\"title\">handler</span>: (<span class=\"params\">fn &amp;&amp; fn.name</span>) || '&lt;<span class=\"title\">anonymous</span>&gt;'</span></span><br><span class=\"line\"><span class=\"function\">                      &#125;</span></span><br><span class=\"line\"><span class=\"function\">                    &#125;</span></span><br><span class=\"line\"><span class=\"function\">                  &#125;,</span></span><br><span class=\"line\"><span class=\"function\">                  <span class=\"title\">fn</span>,</span></span><br><span class=\"line\"><span class=\"function\">                  <span class=\"title\">before</span></span></span><br><span class=\"line\"><span class=\"function\">                ),</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">capture</span>,</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">secure</span></span></span><br><span class=\"line\"><span class=\"function\">              );</span></span><br><span class=\"line\"><span class=\"function\">            &#125;;</span></span><br><span class=\"line\"><span class=\"function\">          &#125;,</span></span><br><span class=\"line\"><span class=\"function\">          <span class=\"title\">wrappedBuiltIns</span></span></span><br><span class=\"line\"><span class=\"function\">        );</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">fill</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          proto,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          <span class=\"string\">'removeEventListener'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">          function(orig</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt, fn, capture, secure</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                fn = fn &amp;&amp; (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ignore, accessing __raven_wrapper__ will throw in some Selenium environments</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> orig.call(<span class=\"keyword\">this</span>, evt, fn, capture, secure);</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          wrappedBuiltIns</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码兼容了通过 handleEvent 的方式进行绑定事件（如果没有听说过这种方式，可以在<a href=\"http://www.ayqy.net/blog/handleevent%E4%B8%8Eaddeventlistener/\" target=\"_blank\" rel=\"noopener\">这里</a>补充一些相关的知识）。</p>\n<p>默认情况下，raven.js 只记录通过 <code>EventTarget.addEventListener</code> 绑定的点击和输入信息，实际上这是比较科学的，并且这些信息较为有效。另外，raven.js 也提供了记录所有点击和输入信息的可选项，其实现方式更为简单，直接在 document 上添加相关的监听即可。</p>\n<h3 id=\"raven-js-如何和框架配合使用\"><a href=\"#raven-js-如何和框架配合使用\" class=\"headerlink\" title=\"raven.js 如何和框架配合使用\"></a>raven.js 如何和框架配合使用</h3><p>raven.js 和框架配合使用的方式非常简单，但是我们要知道，很多框架内置了错误边界处理，或者对错误进行转义。以至于我们通过 window.onerror 的方式得不到完整的错误信息。同时，有些框架提供了错误处理的接口（比如 vue），利用错误处理的接口，我们能够获取到和错误有关的更多更重要的信息。</p>\n<p>raven.js 利用各个框架的官方接口，提供了 vue、require.js、angular、ember、react-native 等各个框架的官方插件。</p>\n<p>插件内容本身非常简单，我们可以看一下 vue 插件的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatComponentName</span>(<span class=\"params\">vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.$root === vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'root instance'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    (name ? <span class=\"string\">'component &lt;'</span> + name + <span class=\"string\">'&gt;'</span> : <span class=\"string\">'anonymous component'</span>) +</span><br><span class=\"line\">    (vm._isVue &amp;&amp; vm.$options.__file ? <span class=\"string\">' at '</span> + vm.$options.__file : <span class=\"string\">''</span>)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vuePlugin</span>(<span class=\"params\">Raven, Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue = Vue || <span class=\"built_in\">window</span>.Vue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// quit if Vue isn't on the page</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Vue || !Vue.config) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _oldOnError = Vue.config.errorHandler;</span><br><span class=\"line\">  Vue.config.errorHandler = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">VueErrorHandler</span>(<span class=\"params\">error, vm, info</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> metaData = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// vm and lifecycleHook are not always available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(vm) === <span class=\"string\">'[object Object]'</span>) &#123;</span><br><span class=\"line\">      metaData.componentName = formatComponentName(vm);</span><br><span class=\"line\">      metaData.propsData = vm.$options.propsData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> info !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      metaData.lifecycleHook = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Raven.captureException(error, &#123;</span><br><span class=\"line\">      extra: metaData</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> _oldOnError === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      _oldOnError.call(<span class=\"keyword\">this</span>, error, vm, info);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = vuePlugin;</span><br></pre></td></tr></table></figure>\n<p>应该不用进行过多解释。</p>\n<p>你也许想知道为什么没有提供 react 插件，事实上，react 16 以后才引入了<a href=\"https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html\" target=\"_blank\" rel=\"noopener\">Error Boundaries</a>，这种方式由于灵活性太强，并不太适合使用插件，另外，就算不使用插件，也非常方便地使用 raven.js 进行错误上报，可以参考<a href=\"https://docs.sentry.io/clients/javascript/integrations/react/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<blockquote>\n<p>但笔者认为，目前 react 的引入方式会对源代码进行侵入，并且比较难通过构建的方式进行 sentry 的配置，也许我们可以寻找更好的方式。</p>\n</blockquote>\n<p>完。</p>\n"},{"title":"多组件单页列表应用的代码组织实践","date":"2018-11-10T14:25:44.000Z","_content":"\n本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。\n\n### 什么是多组件单页面列表应用？\n\n目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。\n\n由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：\n\n![](/img/kd.jpg)\n\n这类应用其实有如下特点：\n\n* 属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。\n* 模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。\n\n当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。\n\n如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：\n\n* 图片等资源的懒加载。\n* 列表虚拟滚动，即使用有限的元素，优化CSS写法等。\n* 使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。\n\n### 多组件单页面应用的维护困境\n\n对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。\n\n我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。\n\n但是随着项目发展，我们会发现，问题慢慢地产生了：\n\n* 单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。\n* 除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。\n* 第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。\n\n如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。\n\n### 多组件单页面应用的组件规划\n\n既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。\n\n经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：\n\n![](/img/kds.jpg)\n\n这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。\n\n这里首先是零件层，零件层应该有如下内容：\n\n* 图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。\n* 标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。\n* 描述内容组件，例如双世宠妃的两行剧集描述。\n* 元信息内容组件，例如普通图文的来源和发表时间。\n* 时长组件，视频图文中用到。\n* 带有描述性的图片组件，视频图文中用到。\n* 图标组件：可以承载图标。\n\n以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。\n\n接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：\n\n* 图标+文字的组合器标题。\n\n对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。\n\n接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：\n\n* 第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。\n* 第二种是右图左文形式，左边的可配置内容和上文右边相同。\n\n当然，这两种整合成一种也无妨。\n\n在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。\n\n最后是控制器层，**在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。**\n\n控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。\n\n通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。\n\n### 总结\n\n通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。\n\n当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。","source":"_posts/多组件单页列表应用的代码组织实践.md","raw":"---\ntitle: 多组件单页列表应用的代码组织实践\ndate: 2018-11-10 22:25:44\ntags:\n\t- 组件化\n---\n\n本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。\n\n### 什么是多组件单页面列表应用？\n\n目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。\n\n由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：\n\n![](/img/kd.jpg)\n\n这类应用其实有如下特点：\n\n* 属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。\n* 模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。\n\n当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。\n\n如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：\n\n* 图片等资源的懒加载。\n* 列表虚拟滚动，即使用有限的元素，优化CSS写法等。\n* 使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。\n\n### 多组件单页面应用的维护困境\n\n对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。\n\n我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。\n\n但是随着项目发展，我们会发现，问题慢慢地产生了：\n\n* 单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。\n* 除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。\n* 第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。\n\n如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。\n\n### 多组件单页面应用的组件规划\n\n既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。\n\n经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：\n\n![](/img/kds.jpg)\n\n这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。\n\n这里首先是零件层，零件层应该有如下内容：\n\n* 图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。\n* 标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。\n* 描述内容组件，例如双世宠妃的两行剧集描述。\n* 元信息内容组件，例如普通图文的来源和发表时间。\n* 时长组件，视频图文中用到。\n* 带有描述性的图片组件，视频图文中用到。\n* 图标组件：可以承载图标。\n\n以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。\n\n接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：\n\n* 图标+文字的组合器标题。\n\n对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。\n\n接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：\n\n* 第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。\n* 第二种是右图左文形式，左边的可配置内容和上文右边相同。\n\n当然，这两种整合成一种也无妨。\n\n在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。\n\n最后是控制器层，**在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。**\n\n控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。\n\n通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。\n\n### 总结\n\n通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。\n\n当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。","slug":"多组件单页列表应用的代码组织实践","published":1,"updated":"2020-02-17T12:50:55.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6nz00038zomx11qm6o7","content":"<p>本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。</p>\n<h3 id=\"什么是多组件单页面列表应用？\"><a href=\"#什么是多组件单页面列表应用？\" class=\"headerlink\" title=\"什么是多组件单页面列表应用？\"></a>什么是多组件单页面列表应用？</h3><p>目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。</p>\n<p>由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：</p>\n<p><img src=\"/img/kd.jpg\" alt=\"\"></p>\n<p>这类应用其实有如下特点：</p>\n<ul>\n<li>属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。</li>\n<li>模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。</li>\n</ul>\n<p>当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。</p>\n<p>如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：</p>\n<ul>\n<li>图片等资源的懒加载。</li>\n<li>列表虚拟滚动，即使用有限的元素，优化CSS写法等。</li>\n<li>使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。</li>\n</ul>\n<h3 id=\"多组件单页面应用的维护困境\"><a href=\"#多组件单页面应用的维护困境\" class=\"headerlink\" title=\"多组件单页面应用的维护困境\"></a>多组件单页面应用的维护困境</h3><p>对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。</p>\n<p>我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。</p>\n<p>但是随着项目发展，我们会发现，问题慢慢地产生了：</p>\n<ul>\n<li>单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。</li>\n<li>除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。</li>\n<li>第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。</li>\n</ul>\n<p>如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。</p>\n<h3 id=\"多组件单页面应用的组件规划\"><a href=\"#多组件单页面应用的组件规划\" class=\"headerlink\" title=\"多组件单页面应用的组件规划\"></a>多组件单页面应用的组件规划</h3><p>既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。</p>\n<p>经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：</p>\n<p><img src=\"/img/kds.jpg\" alt=\"\"></p>\n<p>这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。</p>\n<p>这里首先是零件层，零件层应该有如下内容：</p>\n<ul>\n<li>图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。</li>\n<li>标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。</li>\n<li>描述内容组件，例如双世宠妃的两行剧集描述。</li>\n<li>元信息内容组件，例如普通图文的来源和发表时间。</li>\n<li>时长组件，视频图文中用到。</li>\n<li>带有描述性的图片组件，视频图文中用到。</li>\n<li>图标组件：可以承载图标。</li>\n</ul>\n<p>以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。</p>\n<p>接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：</p>\n<ul>\n<li>图标+文字的组合器标题。</li>\n</ul>\n<p>对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。</p>\n<p>接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：</p>\n<ul>\n<li>第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。</li>\n<li>第二种是右图左文形式，左边的可配置内容和上文右边相同。</li>\n</ul>\n<p>当然，这两种整合成一种也无妨。</p>\n<p>在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。</p>\n<p>最后是控制器层，<strong>在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。</strong></p>\n<p>控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。</p>\n<p>通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。</p>\n<p>当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要对多组件单页面列表应用的代码组织实践进行总结，从而给相关应用的 Web 开发提供参考。</p>\n<h3 id=\"什么是多组件单页面列表应用？\"><a href=\"#什么是多组件单页面列表应用？\" class=\"headerlink\" title=\"什么是多组件单页面列表应用？\"></a>什么是多组件单页面列表应用？</h3><p>目前，其实多组件单页面列表应用非常常见，也是我们日常生活中使用非常高频的一个类别的应用，最典型的比如新闻信息流产品腾讯新闻、今日头条等这类新闻应用，在这类新闻应用中，往往图片、图文、视频、问答、投票等多种模块混杂排列。再简单一点的话，知乎、豆瓣甚至一些论坛以及一些购物软件，也可以归为此类应用。</p>\n<p>由于笔者在负责QQ看点搜索模块的相关内容， 因此，这里给出一个QQ看点搜索的展示图：</p>\n<p><img src=\"/img/kd.jpg\" alt=\"\"></p>\n<p>这类应用其实有如下特点：</p>\n<ul>\n<li>属于长列表滚动，内容随着滚动不断加载，一般在用户返回之前可能积累了大量的内容，因此可能会造成一定的性能问题。</li>\n<li>模块众多，并且模块的种类和样式更新迭代快，这给我们在复用组件的选择上带来了挑战，如果我们盲目复用组件，则会造成胶水代码越来越多，如果不复用组件，那么代码量会随着业务发展线性增长，这都给我们后续的维护带来了挑战。</li>\n</ul>\n<p>当然，一般的基于 Web 的应用（实际上，QQ看点搜索并不完全是纯粹的 WebView 应用）所面临的问题这里也都会遇到。不过，上述两类问题应该算是这类应用的比较重要的问题，其实归根到底，前者是性能问题（面向用户），后者是维护问题（面向开发者）。</p>\n<p>如何解决这里的性能问题，其实已经有很多常规的方案可以借鉴了，这并不是本篇文章的重点，除了传统 Web 用到的性能优化方法，这里仅仅列举一些常规的做法：</p>\n<ul>\n<li>图片等资源的懒加载。</li>\n<li>列表虚拟滚动，即使用有限的元素，优化CSS写法等。</li>\n<li>使用跨端融合方案渲染，例如 Weex、ReactNative、Hippy 等。</li>\n</ul>\n<h3 id=\"多组件单页面应用的维护困境\"><a href=\"#多组件单页面应用的维护困境\" class=\"headerlink\" title=\"多组件单页面应用的维护困境\"></a>多组件单页面应用的维护困境</h3><p>对于这类多组件单页面应用，一般都是增量发展的，即最开始只有很个别的几个模块，随着业务越来越复杂，模块越来越多，逻辑也越来越复杂。</p>\n<p>我们一开始，肯定可以想到一个模块（即上文中灰色分割线分割的一块）是一个组件，不同组件之间抽离出公共的函数，或者采用 mixin 将公共的部分抽离，至于数据端，由于这类应用通常在深度上不复杂，直接采用 React 或者 Vue 提供的父子组件通信的方式一般就够用了。这样设计既满足组件化的思路，也能够方便的维护项目，比较适合项目的初期。</p>\n<p>但是随着项目发展，我们会发现，问题慢慢地产生了：</p>\n<ul>\n<li>单元组件非常不好界定，比如一个左图右文的图文混排组件（例如刘亦菲的热点），之后又会增加左视频右文字，和图文展示的区别不大但是加了视频的播放时长，之后又加了左视频集合右文字（例如双世宠妃第一部分），如果我们把这多类内容当作一个组件，我们的组件中就会有非常多的判断代码，那么就会有大量的代码冗余，或者设计复杂的 mixin 和工具函数。</li>\n<li>除了我们自身的问题，往往随着内容增多，后端返回的数据内容也会非常的不一致，在相似甚至相同的组件中，数据格式也不尽相同，我们需要在我们的单元组件中，来解析判断多种数据格式。</li>\n<li>第三点就是样式更新隐患，当我们的组件多了之后，如果我们对我们的组件进行更新，那么很可能需要同时更新多处（嗯，全局替换也许是个不错的主意），这也是相当有风险的，也许会无意间改动我们并不想改动的 UI。</li>\n</ul>\n<p>如果我们等项目复杂后面对这个问题，我们会发现改动前期的代码工作量比较巨大，但是这又是我们不得不做的事情，这类问题的产生，实际上主要原因是我们的组件设计规划的不合理，我们完全可以在最初的项目中，通过一定的设计规划，来规避这些问题。</p>\n<h3 id=\"多组件单页面应用的组件规划\"><a href=\"#多组件单页面应用的组件规划\" class=\"headerlink\" title=\"多组件单页面应用的组件规划\"></a>多组件单页面应用的组件规划</h3><p>既然，我们现在希望设计一套比较好的组件规划，我们就需要重新审视我们的项目，对于我们的项目而言，一个业务模块一个组件的方式，的确简单方便，但是这样粗放的组件划分原则，实际上并不能完全满足我们复杂的维护需求，反而会给我们带来困扰。</p>\n<p>经过一系列的重构和整理，目前QQ看点搜索的组件规划逻辑是这样的：</p>\n<p><img src=\"/img/kds.jpg\" alt=\"\"></p>\n<p>这里为了方便理解，我们采取上面样例图片中比较常见的一类业务：图文混排条目（左图右文和右图左文）来进行举例，如何设计组件来让提高我们项目的可维护性。</p>\n<p>这里首先是零件层，零件层应该有如下内容：</p>\n<ul>\n<li>图片零件，定宽，定高，自带懒加载，正常情况下只需传入一个 URL 即可使用。</li>\n<li>标题组件，一行标题和两行标题可以设计成两个组件，但进行 CSS 层面的复用。</li>\n<li>描述内容组件，例如双世宠妃的两行剧集描述。</li>\n<li>元信息内容组件，例如普通图文的来源和发表时间。</li>\n<li>时长组件，视频图文中用到。</li>\n<li>带有描述性的图片组件，视频图文中用到。</li>\n<li>图标组件：可以承载图标。</li>\n</ul>\n<p>以上各个组件的内容，几乎都足够简单，只需传入一个 props 作为内容，一般情况下，组件中不能出现 if 或 switch 等逻辑。</p>\n<p>接下来是组合器部分，组合器也是零件，只不过是零件的组合，其实也可以设计的比较薄弱，从而将更多的功能在布局器中完成，但是个别的时候，有这一层会给我们带来一定的方便，这里比如：</p>\n<ul>\n<li>图标+文字的组合器标题。</li>\n</ul>\n<p>对于零件层和组合层，一般情况下都不需要有影响外部的 margin 和 padding，即如果不增加任何多余样式罗列零件层和组合层，其上下左右四边应该是互相贴合的。</p>\n<p>接下来是布局层，这里的布局层，其实可以进行多种方式的设计，根据设计不同其数目也不同，这里给出一种设计方式：</p>\n<ul>\n<li>第一种是左图右文形式，右边可以选择普通图片、普通图片+时长组件、普通图片+描述。右边可以在一行标题、两行标题、描述零件、元信息零件中任意选择和组合。</li>\n<li>第二种是右图左文形式，左边的可配置内容和上文右边相同。</li>\n</ul>\n<p>当然，这两种整合成一种也无妨。</p>\n<p>在布局层，是拥有事件能力的，但是其主要应该是绑定响应时间并且调用通过 props 传入的回调函数，其不应该自己执行事件的响应逻辑。</p>\n<p>最后是控制器层，<strong>在控制器层，除了包裹标签之外，不应该出现任何 html 标签，其也不应当引用除了布局层组件以外的更深层次的组件。控制层的主要作用是进行数据处理。</strong></p>\n<p>控制层的分类方式和上述几层稍有不同，这里，我们就不是按照 UI 来分不同的控制器了，而是按照数据或者业务来分类，因为这里我们主要是进行数据逻辑的处理，和 UI 的关系不是那么重要了（已经将 UI 的压力进行了下沉）。</p>\n<p>通过上述的做法，之后如果有新的需求增加进来，我们根据需要，在不同层级的组件增加内容就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上的逻辑，我们把组件划分的更加清晰明确，将 UI 展示和数据逻辑分离，并且方便我们对样式进行迭代升级。</p>\n<p>当然，这个时候你也许还会问，如果我对部分组件样式进行升级改造，怎么样防止对原有的样式无影响呢？暂时还没有好的办法，不过，我们正在做的 UI 自动化测试套件——mangosteen，可以完美解决这个问题，敬请期待。</p>\n"},{"title":"入门WebAssembly以及使用其进行图像卷积处理","date":"2019-02-16T11:15:51.000Z","_content":"\n> WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。\n\n### 简介\n\n首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。\n\n以下仅列举部分可以支持 WebAssembly 转化的语言：\n\n* [AssemblyScript](https://github.com/AssemblyScript/assemblyscript): 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n* c\\c++: 官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n* [Rust](https://www.rust-lang.org/): 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n* [Kotlin](http://kotlinlang.org/): 语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n* [Golang](https://golang.org/): 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n尝试使用 WebAssembly 官方推荐的方式，我们首先可以在[这里](http://webassembly.org.cn/getting-started/developers-guide/)来下载。\n\n如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。\n\n```\nexport https_proxy=\"http://127.0.0.1:8899\"\nexport http_proxy=\"http://127.0.0.1:8899\"\n// 文件代理：\nhttps://s3.amazonaws.com/mozilla-games/emscripten/packages/node-v8.9.1-darwin-x64.tar.gz file:///Users/niexiaotao/node-v8.9.1-darwin-x64.tar.gz\n```\n\n## 初体验\n\n这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：\n\n```\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n通过类似 `asc f.ts -o f.wasm` 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：\n\nNode：\n\n```\nconst fs = require(\"fs\");\nconst wasm = new WebAssembly.Module(\n    fs.readFileSync(__dirname + \"/f.wasm\"), {}\n);\nconst myModule = new WebAssembly.Instance(wasm).exports;\nconsole.log(myModule.f(12));\n```\n\n浏览器：\n\n```\nfetch('f.wasm') // 网络加载 f.wasm 文件\n        .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n        .then( buffer =>\n            WebAssembly.compile(buffer)\n        )\n        .then(module => { // 调用模块实例上的 f 函数计算\n            const instance = new WebAssembly.Instance(module);\n            const { f } = instance.exports;\n            console.log('instance:', instance.exports);\n            console.log('f(20):', f(20));\n        });\n```\n\n于是，我们完成了 WebAssembly 的初体验。\n\n当然，这个例子太简单了。\n\n## 使用 WebAssembly 进行图像卷积处理\n\n实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。\n\n接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在[这里](http://assembly.niexiaotao.com/)体验。\n\n每次进行卷积处理，我们的整个流程是这样的：\n\n* 将原图像使用 canvas 绘制到屏幕上。\n* 使用 `getImageData` 获取图像像素内容，并转化成类型数组。\n* 将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。\n* WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。\n* 将最终结果通过 canvas 画布更新。\n\n上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。\n\n关于数据通信的问题，这里还有一个比较直白的[科普文章](https://segmentfault.com/a/1190000010434237)，可以参考。\n\n在这里没有必要对整个项目代码进行展示，因此可以参考（[代码地址](https://github.com/aircloud/assemConvolution)），我们这里仅仅对部分关键代码进行说明。\n\n### 共享内存\n\n首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：\n\n```\nlet memory = new WebAssembly.Memory({ initial: ((memSize + 0xffff) & ~0xffff) >>> 16 });\n```\n\n这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory)，实际上 memSize 即我们共享内存的字节数。\n\n然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。\n\n这里我们共享内存所传递的数据按照如下的规则进行设计：\n\n![](http://niexiaotao.cn/img/ker1.jpg)\n\n传递给 WebAssembly 端的方式并不复杂，直接在 `WebAssembly.instantiate` 中声明即可。 \n\n```\nfetch(wasmPath)\n     .then(response => response.arrayBuffer())\n     .then(buffer => WebAssembly.instantiate(buffer, {\n         env: {\n             memory,\n             abort: function() {}\n         },\n         Math\n     })).then(module => {})\n                \n```\n\n然后我们在 AssemblyScript 中就可以进行读写了：\n\n```\n//写：\nstore<u32>(position, v) // position 为位置\n\n//读：\nload<u32>(position) // position 为位置\n```\n\n而在 JavaScript 端，我们也可以通过 `memory.buffer` 拿到数据，并且转化成类型数组：\n\n```\nlet mem = new Uint32Array(memory.buffer)\n//通过 mem.set(data) 可以在 JavaScript 端进行写入操作\n```\n\n这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。\n\n这里需要注意的是，**JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR**\n\n### 卷积计算\n\n我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：\n\n* 我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）\n* 卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。\n\n以上都在代码中有所体现，参考相关代码便可明了。\n\n卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 `putImageData` 上屏即可。\n\n### 其他\n\n当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。\n","source":"_posts/入门WebAssembly以及使用其进行图像卷积处理.md","raw":"---\ntitle: 入门WebAssembly以及使用其进行图像卷积处理\ndate: 2019-02-16 19:15:51\ntags:\n    - WebAssembly\n---\n\n> WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。\n\n### 简介\n\n首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。\n\n以下仅列举部分可以支持 WebAssembly 转化的语言：\n\n* [AssemblyScript](https://github.com/AssemblyScript/assemblyscript): 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；\n* c\\c++: 官方推荐的方式，详细使用见[文档](http://webassembly.org.cn/getting-started/developers-guide/);\n* [Rust](https://www.rust-lang.org/): 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见[文档](https://github.com/rust-lang-nursery/rust-wasm);\n* [Kotlin](http://kotlinlang.org/): 语法和 Java、JS 相似，语言学习成本低，详细使用见[文档](https://kotlinlang.org/docs/reference/native-overview.html);\n* [Golang](https://golang.org/): 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见[文档](https://blog.gopheracademy.com/advent-2017/go-wasm/)。\n\n尝试使用 WebAssembly 官方推荐的方式，我们首先可以在[这里](http://webassembly.org.cn/getting-started/developers-guide/)来下载。\n\n如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。\n\n```\nexport https_proxy=\"http://127.0.0.1:8899\"\nexport http_proxy=\"http://127.0.0.1:8899\"\n// 文件代理：\nhttps://s3.amazonaws.com/mozilla-games/emscripten/packages/node-v8.9.1-darwin-x64.tar.gz file:///Users/niexiaotao/node-v8.9.1-darwin-x64.tar.gz\n```\n\n## 初体验\n\n这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：\n\n```\nexport function f(x: i32): i32 {\n    if (x === 1 || x === 2) {\n        return 1;\n    }\n    return f(x - 1) + f(x - 2)\n}\n```\n\n通过类似 `asc f.ts -o f.wasm` 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：\n\nNode：\n\n```\nconst fs = require(\"fs\");\nconst wasm = new WebAssembly.Module(\n    fs.readFileSync(__dirname + \"/f.wasm\"), {}\n);\nconst myModule = new WebAssembly.Instance(wasm).exports;\nconsole.log(myModule.f(12));\n```\n\n浏览器：\n\n```\nfetch('f.wasm') // 网络加载 f.wasm 文件\n        .then(res => res.arrayBuffer()) // 转成 ArrayBuffer\n        .then( buffer =>\n            WebAssembly.compile(buffer)\n        )\n        .then(module => { // 调用模块实例上的 f 函数计算\n            const instance = new WebAssembly.Instance(module);\n            const { f } = instance.exports;\n            console.log('instance:', instance.exports);\n            console.log('f(20):', f(20));\n        });\n```\n\n于是，我们完成了 WebAssembly 的初体验。\n\n当然，这个例子太简单了。\n\n## 使用 WebAssembly 进行图像卷积处理\n\n实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。\n\n接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在[这里](http://assembly.niexiaotao.com/)体验。\n\n每次进行卷积处理，我们的整个流程是这样的：\n\n* 将原图像使用 canvas 绘制到屏幕上。\n* 使用 `getImageData` 获取图像像素内容，并转化成类型数组。\n* 将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。\n* WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。\n* 将最终结果通过 canvas 画布更新。\n\n上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。\n\n关于数据通信的问题，这里还有一个比较直白的[科普文章](https://segmentfault.com/a/1190000010434237)，可以参考。\n\n在这里没有必要对整个项目代码进行展示，因此可以参考（[代码地址](https://github.com/aircloud/assemConvolution)），我们这里仅仅对部分关键代码进行说明。\n\n### 共享内存\n\n首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：\n\n```\nlet memory = new WebAssembly.Memory({ initial: ((memSize + 0xffff) & ~0xffff) >>> 16 });\n```\n\n这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory)，实际上 memSize 即我们共享内存的字节数。\n\n然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。\n\n这里我们共享内存所传递的数据按照如下的规则进行设计：\n\n![](http://niexiaotao.cn/img/ker1.jpg)\n\n传递给 WebAssembly 端的方式并不复杂，直接在 `WebAssembly.instantiate` 中声明即可。 \n\n```\nfetch(wasmPath)\n     .then(response => response.arrayBuffer())\n     .then(buffer => WebAssembly.instantiate(buffer, {\n         env: {\n             memory,\n             abort: function() {}\n         },\n         Math\n     })).then(module => {})\n                \n```\n\n然后我们在 AssemblyScript 中就可以进行读写了：\n\n```\n//写：\nstore<u32>(position, v) // position 为位置\n\n//读：\nload<u32>(position) // position 为位置\n```\n\n而在 JavaScript 端，我们也可以通过 `memory.buffer` 拿到数据，并且转化成类型数组：\n\n```\nlet mem = new Uint32Array(memory.buffer)\n//通过 mem.set(data) 可以在 JavaScript 端进行写入操作\n```\n\n这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。\n\n这里需要注意的是，**JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR**\n\n### 卷积计算\n\n我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：\n\n* 我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）\n* 卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。\n\n以上都在代码中有所体现，参考相关代码便可明了。\n\n卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 `putImageData` 上屏即可。\n\n### 其他\n\n当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。\n","slug":"入门WebAssembly以及使用其进行图像卷积处理","published":1,"updated":"2020-02-17T12:50:55.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o300068zomuwzm55wu","content":"<blockquote>\n<p>WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。</p>\n</blockquote>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。</p>\n<p>以下仅列举部分可以支持 WebAssembly 转化的语言：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\" target=\"_blank\" rel=\"noopener\">AssemblyScript</a>: 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++: 官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust</a>: 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">Kotlin</a>: 语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">Golang</a>: 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>尝试使用 WebAssembly 官方推荐的方式，我们首先可以在<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">这里</a>来下载。</p>\n<p>如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"attr\">https_proxy=</span><span class=\"string\">\"http://127.0.0.1:8899\"</span></span><br><span class=\"line\">export <span class=\"attr\">http_proxy=</span><span class=\"string\">\"http://127.0.0.1:8899\"</span></span><br><span class=\"line\">// 文件代理：</span><br><span class=\"line\">https://s3.amazonaws.com/mozilla-games/emscripten/packages/<span class=\"keyword\">node</span><span class=\"title\">-v8</span>.<span class=\"number\">9.1</span>-darwin-x64.tar.gz file:///Users/niexiaotao/<span class=\"keyword\">node</span><span class=\"title\">-v8</span>.<span class=\"number\">9.1</span>-darwin-x64.tar.gz</span><br></pre></td></tr></table></figure>\n<h2 id=\"初体验\"><a href=\"#初体验\" class=\"headerlink\" title=\"初体验\"></a>初体验</h2><p>这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x: i32)</span>: i32 </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"number\">1</span> || x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x - <span class=\"number\">1</span>) + f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过类似 <code>asc f.ts -o f.wasm</code> 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：</p>\n<p>Node：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasm = <span class=\"keyword\">new</span> WebAssembly.Module(</span><br><span class=\"line\">    fs.readFileSync(__dirname + <span class=\"string\">\"/f.wasm\"</span>), &#123;&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule = <span class=\"keyword\">new</span> WebAssembly.Instance(wasm).exports;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule.f(<span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n<p>浏览器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'f.wasm'</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">        .then( <span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span></span><br><span class=\"line\">            WebAssembly.compile(buffer)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; f &#125; = instance.exports;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'instance:'</span>, instance.exports);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'f(20):'</span>, f(<span class=\"number\">20</span>));</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>于是，我们完成了 WebAssembly 的初体验。</p>\n<p>当然，这个例子太简单了。</p>\n<h2 id=\"使用-WebAssembly-进行图像卷积处理\"><a href=\"#使用-WebAssembly-进行图像卷积处理\" class=\"headerlink\" title=\"使用 WebAssembly 进行图像卷积处理\"></a>使用 WebAssembly 进行图像卷积处理</h2><p>实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。</p>\n<p>接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在<a href=\"http://assembly.niexiaotao.com/\" target=\"_blank\" rel=\"noopener\">这里</a>体验。</p>\n<p>每次进行卷积处理，我们的整个流程是这样的：</p>\n<ul>\n<li>将原图像使用 canvas 绘制到屏幕上。</li>\n<li>使用 <code>getImageData</code> 获取图像像素内容，并转化成类型数组。</li>\n<li>将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。</li>\n<li>WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。</li>\n<li>将最终结果通过 canvas 画布更新。</li>\n</ul>\n<p>上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。</p>\n<p>关于数据通信的问题，这里还有一个比较直白的<a href=\"https://segmentfault.com/a/1190000010434237\" target=\"_blank\" rel=\"noopener\">科普文章</a>，可以参考。</p>\n<p>在这里没有必要对整个项目代码进行展示，因此可以参考（<a href=\"https://github.com/aircloud/assemConvolution\" target=\"_blank\" rel=\"noopener\">代码地址</a>），我们这里仅仅对部分关键代码进行说明。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let memory = <span class=\"built_in\">new</span> WebAssembly.Memory(&#123; initial: ((memSize + <span class=\"number\">0xffff</span>) &amp; ~<span class=\"number\">0xffff</span>) &gt;&gt;&gt; <span class=\"number\">16</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory\" target=\"_blank\" rel=\"noopener\">这里</a>，实际上 memSize 即我们共享内存的字节数。</p>\n<p>然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。</p>\n<p>这里我们共享内存所传递的数据按照如下的规则进行设计：</p>\n<p><img src=\"http://niexiaotao.cn/img/ker1.jpg\" alt=\"\"></p>\n<p>传递给 WebAssembly 端的方式并不复杂，直接在 <code>WebAssembly.instantiate</code> 中声明即可。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(wasmPath)</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.arrayBuffer())</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span> WebAssembly.instantiate(buffer, &#123;</span><br><span class=\"line\">         env: &#123;</span><br><span class=\"line\">             memory,</span><br><span class=\"line\">             abort: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"built_in\">Math</span></span><br><span class=\"line\">     &#125;)).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后我们在 AssemblyScript 中就可以进行读写了：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//写：</span></span><br><span class=\"line\">store&lt;u32&gt;(<span class=\"built_in\">position</span>, v) <span class=\"comment\">// position 为位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读：</span></span><br><span class=\"line\"><span class=\"built_in\">load</span>&lt;u32&gt;(<span class=\"built_in\">position</span>) <span class=\"comment\">// position 为位置</span></span><br></pre></td></tr></table></figure>\n<p>而在 JavaScript 端，我们也可以通过 <code>memory.buffer</code> 拿到数据，并且转化成类型数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mem = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint32Array</span>(memory.buffer)</span><br><span class=\"line\"><span class=\"comment\">//通过 mem.set(data) 可以在 JavaScript 端进行写入操作</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。</p>\n<p>这里需要注意的是，<strong>JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR</strong></p>\n<h3 id=\"卷积计算\"><a href=\"#卷积计算\" class=\"headerlink\" title=\"卷积计算\"></a>卷积计算</h3><p>我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：</p>\n<ul>\n<li>我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）</li>\n<li>卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。</li>\n</ul>\n<p>以上都在代码中有所体现，参考相关代码便可明了。</p>\n<p>卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 <code>putImageData</code> 上屏即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>WebAssembly 出现有很长时间了，但是由于日常工作并无直接接触，因此一直疏于尝试，最近终于利用一些业余时间简单入门了一下，因此在此总结。</p>\n</blockquote>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>首先我们需要知道 WebAssembly 是一个什么东西，其实际是一个字节码编码方式，比较接近机器码（但是又无法直接执行），这样可以方便地做到跨平台同时省去像 JavaScript 等语言的解释时间，所以是有一定优势的，使用起来其实也比较灵活，凡是可以转化成字节码的，都是可以使用 WebAssembly。</p>\n<p>以下仅列举部分可以支持 WebAssembly 转化的语言：</p>\n<ul>\n<li><a href=\"https://github.com/AssemblyScript/assemblyscript\" target=\"_blank\" rel=\"noopener\">AssemblyScript</a>: 语法和 TypeScript 一致(事实上，其是 Typescript 的一个子集)，对前端来说学习成本低，为前端编写 WebAssembly 最佳选择；</li>\n<li>c\\c++: 官方推荐的方式，详细使用见<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"noopener\">Rust</a>: 语法复杂、学习成本高，对前端来说可能会不适应。详细使用见<a href=\"https://github.com/rust-lang-nursery/rust-wasm\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"http://kotlinlang.org/\" target=\"_blank\" rel=\"noopener\">Kotlin</a>: 语法和 Java、JS 相似，语言学习成本低，详细使用见<a href=\"https://kotlinlang.org/docs/reference/native-overview.html\" target=\"_blank\" rel=\"noopener\">文档</a>;</li>\n<li><a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">Golang</a>: 语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段，详细使用见<a href=\"https://blog.gopheracademy.com/advent-2017/go-wasm/\" target=\"_blank\" rel=\"noopener\">文档</a>。</li>\n</ul>\n<p>尝试使用 WebAssembly 官方推荐的方式，我们首先可以在<a href=\"http://webassembly.org.cn/getting-started/developers-guide/\" target=\"_blank\" rel=\"noopener\">这里</a>来下载。</p>\n<p>如果用腾讯内网有的文件是下载不下来的，这个时候我们可以给命令行增加一个代理（如果我们用的 Fiddler 或 Charles，开启的时候默认命令行也可以走代理，如果是 Whistle，我们需要手动设置代理），有些文件我们还可以下载好之后使用文件代理。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"attr\">https_proxy=</span><span class=\"string\">\"http://127.0.0.1:8899\"</span></span><br><span class=\"line\">export <span class=\"attr\">http_proxy=</span><span class=\"string\">\"http://127.0.0.1:8899\"</span></span><br><span class=\"line\">// 文件代理：</span><br><span class=\"line\">https://s3.amazonaws.com/mozilla-games/emscripten/packages/<span class=\"keyword\">node</span><span class=\"title\">-v8</span>.<span class=\"number\">9.1</span>-darwin-x64.tar.gz file:///Users/niexiaotao/<span class=\"keyword\">node</span><span class=\"title\">-v8</span>.<span class=\"number\">9.1</span>-darwin-x64.tar.gz</span><br></pre></td></tr></table></figure>\n<h2 id=\"初体验\"><a href=\"#初体验\" class=\"headerlink\" title=\"初体验\"></a>初体验</h2><p>这里考虑到前端同学的上手难度，我们先使用 AssemblyScript 写一个极小的例子，一个斐波那契函数：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(x: i32)</span>: i32 </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x === <span class=\"number\">1</span> || x === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x - <span class=\"number\">1</span>) + f(x - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过类似 <code>asc f.ts -o f.wasm</code> 这样的命令编译成 f.wasm 之后，我们可以分别在 Node 环境和浏览器环境来执行：</p>\n<p>Node：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasm = <span class=\"keyword\">new</span> WebAssembly.Module(</span><br><span class=\"line\">    fs.readFileSync(__dirname + <span class=\"string\">\"/f.wasm\"</span>), &#123;&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">const</span> myModule = <span class=\"keyword\">new</span> WebAssembly.Instance(wasm).exports;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myModule.f(<span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n<p>浏览器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'f.wasm'</span>) <span class=\"comment\">// 网络加载 f.wasm 文件</span></span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.arrayBuffer()) <span class=\"comment\">// 转成 ArrayBuffer</span></span><br><span class=\"line\">        .then( <span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span></span><br><span class=\"line\">            WebAssembly.compile(buffer)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123; <span class=\"comment\">// 调用模块实例上的 f 函数计算</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> instance = <span class=\"keyword\">new</span> WebAssembly.Instance(<span class=\"built_in\">module</span>);</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; f &#125; = instance.exports;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'instance:'</span>, instance.exports);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'f(20):'</span>, f(<span class=\"number\">20</span>));</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure>\n<p>于是，我们完成了 WebAssembly 的初体验。</p>\n<p>当然，这个例子太简单了。</p>\n<h2 id=\"使用-WebAssembly-进行图像卷积处理\"><a href=\"#使用-WebAssembly-进行图像卷积处理\" class=\"headerlink\" title=\"使用 WebAssembly 进行图像卷积处理\"></a>使用 WebAssembly 进行图像卷积处理</h2><p>实际上，WebAssembly 的目的在于解决一些复杂的计算问题，优化 JavaScript 的执行效率。所以我们可以使用 WebAssembly 来处理一些图像或者矩阵的计算问题。</p>\n<p>接下来，我们通过 WebAssembly 来处理一些图像的卷积问题，用于图像的风格变换，我们最终的例子可以在<a href=\"http://assembly.niexiaotao.com/\" target=\"_blank\" rel=\"noopener\">这里</a>体验。</p>\n<p>每次进行卷积处理，我们的整个流程是这样的：</p>\n<ul>\n<li>将原图像使用 canvas 绘制到屏幕上。</li>\n<li>使用 <code>getImageData</code> 获取图像像素内容，并转化成类型数组。</li>\n<li>将上述类型数组通过共享内存的方式传递给 WebAssembly 部分。</li>\n<li>WebAssembly 部分接收到数据，进行计算，并且通过共享内存的方式返回。</li>\n<li>将最终结果通过 canvas 画布更新。</li>\n</ul>\n<p>上述各个步骤中，绘制的部分集中在 JavaScript 端，而计算的部分集中在 WebAssembly，这两部分相互比较独立，可以分开编写，而双端数据通信是一个比较值得注意的地方，事实上，我们可以通过 ArrayBuffer 来实现双端通信，简单的说，JavaScript 端和 WebAssembly 可以共享一部分内存，并且都拥有读写能力，当一端写入新数据之后，另一段也可以读到，这样我们就可以进行通信了。</p>\n<p>关于数据通信的问题，这里还有一个比较直白的<a href=\"https://segmentfault.com/a/1190000010434237\" target=\"_blank\" rel=\"noopener\">科普文章</a>，可以参考。</p>\n<p>在这里没有必要对整个项目代码进行展示，因此可以参考（<a href=\"https://github.com/aircloud/assemConvolution\" target=\"_blank\" rel=\"noopener\">代码地址</a>），我们这里仅仅对部分关键代码进行说明。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>首先，我们需要声明一块共享内存，这其实可以使用 WebAssembly 的 API 来完成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let memory = <span class=\"built_in\">new</span> WebAssembly.Memory(&#123; initial: ((memSize + <span class=\"number\">0xffff</span>) &amp; ~<span class=\"number\">0xffff</span>) &gt;&gt;&gt; <span class=\"number\">16</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这里经过这样的比较复杂的计算是因为 initial 传入的是以 page 为单位，详细可以参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory\" target=\"_blank\" rel=\"noopener\">这里</a>，实际上 memSize 即我们共享内存的字节数。</p>\n<p>然后这里涉及到 memSize 的计算，我们主要需要存储三块数据：卷积前的数据、卷积后的数据（由于卷积算法的特殊性以及为了避免更多麻烦，这里我们不进行数据共用），还有卷积核作为参数需要传递。</p>\n<p>这里我们共享内存所传递的数据按照如下的规则进行设计：</p>\n<p><img src=\"http://niexiaotao.cn/img/ker1.jpg\" alt=\"\"></p>\n<p>传递给 WebAssembly 端的方式并不复杂，直接在 <code>WebAssembly.instantiate</code> 中声明即可。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(wasmPath)</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.arrayBuffer())</span><br><span class=\"line\">     .then(<span class=\"function\"><span class=\"params\">buffer</span> =&gt;</span> WebAssembly.instantiate(buffer, &#123;</span><br><span class=\"line\">         env: &#123;</span><br><span class=\"line\">             memory,</span><br><span class=\"line\">             abort: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"built_in\">Math</span></span><br><span class=\"line\">     &#125;)).then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后我们在 AssemblyScript 中就可以进行读写了：</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//写：</span></span><br><span class=\"line\">store&lt;u32&gt;(<span class=\"built_in\">position</span>, v) <span class=\"comment\">// position 为位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读：</span></span><br><span class=\"line\"><span class=\"built_in\">load</span>&lt;u32&gt;(<span class=\"built_in\">position</span>) <span class=\"comment\">// position 为位置</span></span><br></pre></td></tr></table></figure>\n<p>而在 JavaScript 端，我们也可以通过 <code>memory.buffer</code> 拿到数据，并且转化成类型数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mem = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint32Array</span>(memory.buffer)</span><br><span class=\"line\"><span class=\"comment\">//通过 mem.set(data) 可以在 JavaScript 端进行写入操作</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们在 JavaScript 端和 AssemblyScript 端的读写都明晰了。</p>\n<p>这里需要注意的是，<strong>JS端采用的是大端数据格式，而 AssemblyScript 中采用的是小端，因此其颜色数据格式为 AGBR</strong></p>\n<h3 id=\"卷积计算\"><a href=\"#卷积计算\" class=\"headerlink\" title=\"卷积计算\"></a>卷积计算</h3><p>我们所采用的卷积计算本身算法比较简单，并且不是本次的重点，但是这里需要注意的是：</p>\n<ul>\n<li>我们无法直接在 AssemblyScript 中声明数组并使用，因此除了 Kernel 通过共享内存的方式传递过来以外，我们应当尽量避免声明数组使用（虽然也有使用非共享内存数组的相关操作，但是使用起来比较繁琐）</li>\n<li>卷积应当对 R、G、B 三层单独进行，我这里 A 层不参与卷积。</li>\n</ul>\n<p>以上都在代码中有所体现，参考相关代码便可明了。</p>\n<p>卷积完成后，我们通过共享内存的方法写入类型数组，然后在 JavaScript 端合成数据，调用 <code>putImageData</code> 上屏即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>当然，本次图像卷积程序仅仅是对 Webassembly 和 AssemblyScript 的初步尝试，笔者也在学习阶段，如果上述说法有问题或者你想和我交流，也欢迎留言或者提相关 issue。</p>\n"},{"title":"浅谈前端中的二进制数据类型","date":"2018-05-09T02:28:42.000Z","_content":"\n>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。\n\n本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考[这里](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4)而非本人原创，仅做个人学习使用。\n\n这些类型化对象，一般会在以下场景中使用：\n\n* WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。\n* 在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。\n* 在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。\n* 在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。\n* 在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。\n\n下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。\n\n### 二进制数据类型概述\n\n#### ArrayBuffer\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```\nvar buf = new ArrayBuffer(32);\n```\n\n上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\n```\nvar buf = new ArrayBuffer(32);\nvar dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n```\n\n上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。\n\n另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：\n\n```\nvar buffer = new ArrayBuffer(12);\n\nvar x1 = new Int32Array(buffer);\nx1[0] = 1;\nvar x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n```\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\n```\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n```\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\n```\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar newBuffer = buffer.slice(0, 3);\n```\n\n上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\n```\nvar buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nvar v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n```\n\n#### TypedArray\n\n目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。\n\n* Int8Array：8位有符号整数，长度1个字节。\n* Uint8Array：8位无符号整数，长度1个字节。\n* Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。\n* Int16Array：16位有符号整数，长度2个字节。\n* Uint16Array：16位无符号整数，长度2个字节。\n* Int32Array：32位有符号整数，长度4个字节。\n* Uint32Array：32位无符号整数，长度4个字节。\n* Float32Array：32位浮点数，长度4个字节。\n* Float64Array：64位浮点数，长度8个字节。\n\n这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。\n\n* TypedArray数组的所有成员，都是同一种类型和格式。\n* TypedArray数组的成员是连续的，不会有空位。\n* Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。\n* TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n##### 构造函数\n\nTypedArray数组提供9种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n* TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n```\n// 创建一个8字节的ArrayBuffer\nvar b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nvar v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nvar v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nvar v3 = new Int16Array(b, 2, 2);\n```\n\n对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n```\n\n上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。\n\n* TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\n```\nvar f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n```\n\n* TypedArray(typedArray)\n\n类型化数组的构造函数，可以接受另一个视图实例作为参数。\n\n```\nvar typedArray = new Int8Array(new Uint8Array(4));\n```\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n```\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n```\n\n* TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\n```\nvar typedArray = new Uint8Array([1, 2, 3, 4]);\n```\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。\n\nTypedArray数组也可以转换回普通数组。\n\n```\nvar normalArray = Array.prototype.slice.call(typedArray);\n```\n\n##### BYTES_PER_ELEMENT属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\n```\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n```\n\n##### ArrayBuffer与字符串的互相转换\n\nArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。\n\n```\n// ArrayBuffer转为字符串，参数为ArrayBuffer对象\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n// 字符串转为ArrayBuffer对象，参数为字符串\nfunction str2ab(str) {\n  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n```\n\n##### TypedArray.prototype.set()\n\nTypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。\n\n```\nvar a = new Uint8Array(8);\nvar b = new Uint8Array(8);\n\nb.set(a);\n```\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。\n\n```\nvar a = new Uint16Array(8);\nvar b = new Uint16Array(10);\n\nb.set(a, 2)\n```\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n##### TypedArray.prototype.subarray()\n\nsubarray方法是对于TypedArray数组的一部分，再建立一个新的视图。\n\n```\nvar a = new Uint16Array(8);\nvar b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n```\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。\n\n##### TypedArray.prototype.slice()\n\nTypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\n```\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n```\n\n\n上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。\n\n##### TypedArray.of()\n\nTypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\n```\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n```\n\n##### TypedArray.from()\n\n静态方法from接受一个**可遍历的数据结构（比如数组）**作为参数，返回一个基于这个结构的TypedArray实例。\n\n```\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n```\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\n```\nvar ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n```\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\n```\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n```\n\n上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。\n\n#### DataView\n\n如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\n```\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n```\n下面是一个例子。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n```\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n* DataView.prototype.buffer：返回对应的ArrayBuffer对象\n* DataView.prototype.byteLength：返回占据的内存字节长度\n* DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始\n\nDataView实例提供8个方法读取内存。\n\n* getInt8：读取1个字节，返回一个8位整数。\n* getUint8：读取1个字节，返回一个无符号的8位整数。\n* getInt16：读取2个字节，返回一个16位整数。\n* getUint16：读取2个字节，返回一个无符号的16位整数。\n* getInt32：读取4个字节，返回一个32位整数。\n* getUint32：读取4个字节，返回一个无符号的32位整数。\n* getFloat32：读取4个字节，返回一个32位浮点数。\n* getFloat64：读取8个字节，返回一个64位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nvar v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nvar v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nvar v3 = dv.getUint16(3);\n```\n\n上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n```\n// 小端字节序\nvar v1 = dv.getUint16(1, true);\n\n// 大端字节序\nvar v2 = dv.getUint16(3, false);\n\n// 大端字节序\nvar v3 = dv.getUint16(3);\n```\n\nDataView视图提供8个方法写入内存。\n\n* setInt8：写入1个字节的8位整数。\n* setUint8：写入1个字节的8位无符号整数。\n* setInt16：写入2个字节的16位整数。\n* setUint16：写入2个字节的16位无符号整数。\n* setInt32：写入4个字节的32位整数。\n* setUint32：写入4个字节的32位无符号整数。\n* setFloat32：写入4个字节的32位浮点数。\n* setFloat64：写入8个字节的64位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n```\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n```\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\n```\nvar littleEndian = (function() {\n  var buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n```\n\n#### Blob\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。\n\n要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。\n\n从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：\n\n```\nvar reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含转化为类型数组的blob\n});\nreader.readAsArrayBuffer(blob);\n```\n\n更多关于Blob的内容，请直接查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n### 数据格式转换\n\n#### String转Blob\n\n```\n//将字符串 转换成 Blob 对象\nvar blob = new Blob([\"Hello World!\"], {\n    type: 'text/plain'\n});\nconsole.info(blob);\nconsole.info(blob.slice(1, 3, 'text/plain'));\n```\n#### TypeArray转Blob\n\n```\n//将 TypeArray  转换成 Blob 对象\nvar array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);\n//测试成功\n//var blob = new Blob([array], { type: \"application/octet-binary\" });\n//测试成功， 注意必须[]的包裹\nvar blob = new Blob([array]);\n//将 Blob对象 读成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result); //a Hello world!\n}\n```\n\n#### ArrayBuffer转Blob\n\n```\nvar buffer = new ArrayBuffer(32);\nvar blob = new Blob([buffer]);       // 注意必须包裹[]\n```\n\n#### Blob转String\n\n这里需要注意的是readAsText方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result);\n}\n```\n\n#### Blob转ArrayBuffer\n\n这里需要注意的是readAsArrayBuffer方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成 ArrayBuffer\nvar reader = new FileReader();\nreader.readAsArrayBuffer(blob);\nreader.onload = function (e) {\n    console.info(reader.result); //ArrayBuffer {}\n    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n    //var buf = new int16array(reader.result);\n    //console.info(buf);\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new Uint8Array(reader.result);\n    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new DataView(reader.result);\n    console.info(buf); //DataView {}\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n}\n```\n\n","source":"_posts/浅谈前端中的二进制数据类型.md","raw":"---\ntitle: 浅谈前端中的二进制数据类型\ndate: 2018-05-09 10:28:42\ntags:\n\t- javascript\n---\n\n>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。\n\n本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考[这里](http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4)而非本人原创，仅做个人学习使用。\n\n这些类型化对象，一般会在以下场景中使用：\n\n* WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。\n* 在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。\n* 在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。\n* 在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。\n* 在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。\n\n下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。\n\n### 二进制数据类型概述\n\n#### ArrayBuffer\n\nArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n\nArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```\nvar buf = new ArrayBuffer(32);\n```\n\n上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。\n\n为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。\n\n```\nvar buf = new ArrayBuffer(32);\nvar dataView = new DataView(buf);\ndataView.getUint8(0) // 0\n```\n\n上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。\n\n另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：\n\n```\nvar buffer = new ArrayBuffer(12);\n\nvar x1 = new Int32Array(buffer);\nx1[0] = 1;\nvar x2 = new Uint8Array(buffer);\nx2[0]  = 2;\n\nx1[0] // 2\n```\n\nArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。\n\n```\nvar buffer = new ArrayBuffer(32);\nbuffer.byteLength\n// 32\n```\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。\n\n```\nif (buffer.byteLength === n) {\n  // 成功\n} else {\n  // 失败\n}\n```\n\nArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar newBuffer = buffer.slice(0, 3);\n```\n\n上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。\n\nslice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。\n\n除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。\n\nArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。\n\n```\nvar buffer = new ArrayBuffer(8);\nArrayBuffer.isView(buffer) // false\n\nvar v = new Int32Array(buffer);\nArrayBuffer.isView(v) // true\n```\n\n#### TypedArray\n\n目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。\n\n* Int8Array：8位有符号整数，长度1个字节。\n* Uint8Array：8位无符号整数，长度1个字节。\n* Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。\n* Int16Array：16位有符号整数，长度2个字节。\n* Uint16Array：16位无符号整数，长度2个字节。\n* Int32Array：32位有符号整数，长度4个字节。\n* Uint32Array：32位无符号整数，长度4个字节。\n* Float32Array：32位浮点数，长度4个字节。\n* Float64Array：64位浮点数，长度8个字节。\n\n这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。\n\n* TypedArray数组的所有成员，都是同一种类型和格式。\n* TypedArray数组的成员是连续的，不会有空位。\n* Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。\n* TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。\n\n##### 构造函数\n\nTypedArray数组提供9种构造函数，用来生成相应类型的数组实例。\n\n构造函数有多种用法。\n\n* TypedArray(buffer, byteOffset=0, length?)\n\n同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。\n\n```\n// 创建一个8字节的ArrayBuffer\nvar b = new ArrayBuffer(8);\n\n// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾\nvar v1 = new Int32Array(b);\n\n// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾\nvar v2 = new Uint8Array(b, 2);\n\n// 创建一个指向b的Int16视图，开始于字节2，长度为2\nvar v3 = new Int16Array(b, 2, 2);\n```\n\n对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\n\n注意，byteOffset必须与所要建立的数据类型一致，否则会报错。\n\n```\nvar buffer = new ArrayBuffer(8);\nvar i16 = new Int16Array(buffer, 1);\n// Uncaught RangeError: start offset of Int16Array should be a multiple of 2\n```\n\n上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。\n\n如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。\n\n* TypedArray(length)\n\n视图还可以不通过ArrayBuffer对象，直接分配内存而生成。\n\n```\nvar f64a = new Float64Array(8);\nf64a[0] = 10;\nf64a[1] = 20;\nf64a[2] = f64a[0] + f64a[1];\n```\n\n* TypedArray(typedArray)\n\n类型化数组的构造函数，可以接受另一个视图实例作为参数。\n\n```\nvar typedArray = new Int8Array(new Uint8Array(4));\n```\n\n上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。\n\n注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 1\n```\n\n上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。\n\n如果想基于同一段内存，构造不同的视图，可以采用下面的写法。\n\n```\nvar x = new Int8Array([1, 1]);\nvar y = new Int8Array(x.buffer);\nx[0] // 1\ny[0] // 1\n\nx[0] = 2;\ny[0] // 2\n```\n\n* TypedArray(arrayLikeObject)\n\n构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。\n\n```\nvar typedArray = new Uint8Array([1, 2, 3, 4]);\n```\n\n注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。\n\n上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。\n\nTypedArray数组也可以转换回普通数组。\n\n```\nvar normalArray = Array.prototype.slice.call(typedArray);\n```\n\n##### BYTES_PER_ELEMENT属性\n\n每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。\n\n```\nInt8Array.BYTES_PER_ELEMENT // 1\nUint8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nUint16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nUint32Array.BYTES_PER_ELEMENT // 4\nFloat32Array.BYTES_PER_ELEMENT // 4\nFloat64Array.BYTES_PER_ELEMENT // 8\n```\n\n##### ArrayBuffer与字符串的互相转换\n\nArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。\n\n```\n// ArrayBuffer转为字符串，参数为ArrayBuffer对象\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n// 字符串转为ArrayBuffer对象，参数为字符串\nfunction str2ab(str) {\n  var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n```\n\n##### TypedArray.prototype.set()\n\nTypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。\n\n```\nvar a = new Uint8Array(8);\nvar b = new Uint8Array(8);\n\nb.set(a);\n```\n\n上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。\n\n```\nvar a = new Uint16Array(8);\nvar b = new Uint16Array(10);\n\nb.set(a, 2)\n```\n上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。\n\n##### TypedArray.prototype.subarray()\n\nsubarray方法是对于TypedArray数组的一部分，再建立一个新的视图。\n\n```\nvar a = new Uint16Array(8);\nvar b = a.subarray(2,3);\n\na.byteLength // 16\nb.byteLength // 2\n```\n\nsubarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。\n\n##### TypedArray.prototype.slice()\n\nTypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。\n\n```\nlet ui8 = Uint8Array.of(0, 1, 2);\nui8.slice(-1)\n// Uint8Array [ 2 ]\n```\n\n\n上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。\n\nslice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。\n\n##### TypedArray.of()\n\nTypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。\n\n```\nFloat32Array.of(0.151, -8, 3.7)\n// Float32Array [ 0.151, -8, 3.7 ]\n```\n\n##### TypedArray.from()\n\n静态方法from接受一个**可遍历的数据结构（比如数组）**作为参数，返回一个基于这个结构的TypedArray实例。\n\n```\nUint16Array.from([0, 1, 2])\n// Uint16Array [ 0, 1, 2 ]\n```\n\n这个方法还可以将一种TypedArray实例，转为另一种。\n\n```\nvar ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));\nui16 instanceof Uint16Array // true\n```\n\nfrom方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。\n\n```\nInt8Array.of(127, 126, 125).map(x => 2 * x)\n// Int8Array [ -2, -4, -6 ]\n\nInt16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)\n// Int16Array [ 254, 252, 250 ]\n```\n\n上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。\n\n#### DataView\n\n如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。\n\nDataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。\n\nDataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。\n\n```\nDataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);\n```\n下面是一个例子。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n```\n\nDataView实例有以下属性，含义与TypedArray实例的同名方法相同。\n\n* DataView.prototype.buffer：返回对应的ArrayBuffer对象\n* DataView.prototype.byteLength：返回占据的内存字节长度\n* DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始\n\nDataView实例提供8个方法读取内存。\n\n* getInt8：读取1个字节，返回一个8位整数。\n* getUint8：读取1个字节，返回一个无符号的8位整数。\n* getInt16：读取2个字节，返回一个16位整数。\n* getUint16：读取2个字节，返回一个无符号的16位整数。\n* getInt32：读取4个字节，返回一个32位整数。\n* getUint32：读取4个字节，返回一个无符号的32位整数。\n* getFloat32：读取4个字节，返回一个32位浮点数。\n* getFloat64：读取8个字节，返回一个64位浮点数。\n\n这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。\n\n```\nvar buffer = new ArrayBuffer(24);\nvar dv = new DataView(buffer);\n\n// 从第1个字节读取一个8位无符号整数\nvar v1 = dv.getUint8(0);\n\n// 从第2个字节读取一个16位无符号整数\nvar v2 = dv.getUint16(1);\n\n// 从第4个字节读取一个16位无符号整数\nvar v3 = dv.getUint16(3);\n```\n\n上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。\n\n如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。\n\n```\n// 小端字节序\nvar v1 = dv.getUint16(1, true);\n\n// 大端字节序\nvar v2 = dv.getUint16(3, false);\n\n// 大端字节序\nvar v3 = dv.getUint16(3);\n```\n\nDataView视图提供8个方法写入内存。\n\n* setInt8：写入1个字节的8位整数。\n* setUint8：写入1个字节的8位无符号整数。\n* setInt16：写入2个字节的16位整数。\n* setUint16：写入2个字节的16位无符号整数。\n* setInt32：写入4个字节的32位整数。\n* setUint32：写入4个字节的32位无符号整数。\n* setFloat32：写入4个字节的32位浮点数。\n* setFloat64：写入8个字节的64位浮点数。\n\n这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。\n\n```\n// 在第1个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(0, 25, false);\n\n// 在第5个字节，以大端字节序写入值为25的32位整数\ndv.setInt32(4, 25);\n\n// 在第9个字节，以小端字节序写入值为2.5的32位浮点数\ndv.setFloat32(8, 2.5, true);\n```\n\n如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。\n\n```\nvar littleEndian = (function() {\n  var buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(0, 256, true);\n  return new Int16Array(buffer)[0] === 256;\n})();\n```\n\n#### Blob\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。\n\n要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。\n\n从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：\n\n```\nvar reader = new FileReader();\nreader.addEventListener(\"loadend\", function() {\n   // reader.result 包含转化为类型数组的blob\n});\nreader.readAsArrayBuffer(blob);\n```\n\n更多关于Blob的内容，请直接查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n\n### 数据格式转换\n\n#### String转Blob\n\n```\n//将字符串 转换成 Blob 对象\nvar blob = new Blob([\"Hello World!\"], {\n    type: 'text/plain'\n});\nconsole.info(blob);\nconsole.info(blob.slice(1, 3, 'text/plain'));\n```\n#### TypeArray转Blob\n\n```\n//将 TypeArray  转换成 Blob 对象\nvar array = new Uint16Array([97, 32, 72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]);\n//测试成功\n//var blob = new Blob([array], { type: \"application/octet-binary\" });\n//测试成功， 注意必须[]的包裹\nvar blob = new Blob([array]);\n//将 Blob对象 读成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result); //a Hello world!\n}\n```\n\n#### ArrayBuffer转Blob\n\n```\nvar buffer = new ArrayBuffer(32);\nvar blob = new Blob([buffer]);       // 注意必须包裹[]\n```\n\n#### Blob转String\n\n这里需要注意的是readAsText方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成字符串\nvar reader = new FileReader();\nreader.readAsText(blob, 'utf-8');\nreader.onload = function (e) {\n    console.info(reader.result);\n}\n```\n\n#### Blob转ArrayBuffer\n\n这里需要注意的是readAsArrayBuffer方法的使用。\n\n```\n//将字符串转换成 Blob对象\nvar blob = new Blob(['中文字符串'], {\n    type: 'text/plain'\n});\n//将Blob 对象转换成 ArrayBuffer\nvar reader = new FileReader();\nreader.readAsArrayBuffer(blob);\nreader.onload = function (e) {\n    console.info(reader.result); //ArrayBuffer {}\n    //经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n    //var buf = new int16array(reader.result);\n    //console.info(buf);\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new Uint8Array(reader.result);\n    console.info(buf); //[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n\n    //将 ArrayBufferView  转换成Blob\n    var buf = new DataView(reader.result);\n    console.info(buf); //DataView {}\n    reader.readAsText(new Blob([buf]), 'utf-8');\n    reader.onload = function () {\n        console.info(reader.result); //中文字符串\n    };\n}\n```\n\n","slug":"浅谈前端中的二进制数据类型","published":1,"updated":"2020-02-17T12:50:55.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o400078zom7w3sz4gz","content":"<blockquote>\n<p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p>\n</blockquote>\n<p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href=\"http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4\" target=\"_blank\" rel=\"noopener\">这里</a>而非本人原创，仅做个人学习使用。</p>\n<p>这些类型化对象，一般会在以下场景中使用：</p>\n<ul>\n<li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li>\n<li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li>\n<li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li>\n<li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li>\n<li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li>\n</ul>\n<p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p>\n<h3 id=\"二进制数据类型概述\"><a href=\"#二进制数据类型概述\" class=\"headerlink\" title=\"二进制数据类型概述\"></a>二进制数据类型概述</h3><h4 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>\n<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p>\n<p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dataView = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buf);</span><br><span class=\"line\">dataView.getUint8(<span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p>\n<p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(buffer);</span><br><span class=\"line\">x1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(buffer);</span><br><span class=\"line\">x2[<span class=\"number\">0</span>]  = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x1[<span class=\"number\">0</span>] <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"built_in\">buffer</span> = <span class=\"keyword\">new</span> ArrayBuffer(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"built_in\">buffer</span>.byteLength</span><br><span class=\"line\"><span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">if</span> (<span class=\"built_in\">buffer</span>.byteLength === n) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 成功</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Buffer</span> = buffer.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>\n<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>\n<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>\n<p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"built_in\">ArrayBuffer</span>.isView(buffer) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>(buffer);</span><br><span class=\"line\"><span class=\"built_in\">ArrayBuffer</span>.isView(v) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p>\n<ul>\n<li>Int8Array：8位有符号整数，长度1个字节。</li>\n<li>Uint8Array：8位无符号整数，长度1个字节。</li>\n<li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li>\n<li>Int16Array：16位有符号整数，长度2个字节。</li>\n<li>Uint16Array：16位无符号整数，长度2个字节。</li>\n<li>Int32Array：32位有符号整数，长度4个字节。</li>\n<li>Uint32Array：32位无符号整数，长度4个字节。</li>\n<li>Float32Array：32位浮点数，长度4个字节。</li>\n<li>Float64Array：64位浮点数，长度8个字节。</li>\n</ul>\n<p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p>\n<ul>\n<li>TypedArray数组的所有成员，都是同一种类型和格式。</li>\n<li>TypedArray数组的成员是连续的，不会有空位。</li>\n<li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li>\n<li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>\n</ul>\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p>\n<p>构造函数有多种用法。</p>\n<ul>\n<li>TypedArray(buffer, byteOffset=0, length?)</li>\n</ul>\n<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个8字节的ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(b, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(b, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>\n<p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> i16 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p>\n<p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p>\n<ul>\n<li>TypedArray(length)</li>\n</ul>\n<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f64a = new Float64Array(<span class=\"number\">8</span>);</span><br><span class=\"line\">f64a[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\">f64a[<span class=\"number\">1</span>] = <span class=\"number\">20</span>;</span><br><span class=\"line\">f64a[<span class=\"number\">2</span>] = f64a[<span class=\"number\">0</span>] + f64a[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TypedArray(typedArray)</li>\n</ul>\n<p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typedArray = <span class=\"keyword\">new</span> <span class=\"type\">Int8Array</span>(<span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p>\n<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = new Int8Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\">var y = new Int8Array(x);</span><br><span class=\"line\">x[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p>\n<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = new Int8Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\">var y = new Int8Array(x.buffer);</span><br><span class=\"line\">x[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>TypedArray(arrayLikeObject)</li>\n</ul>\n<p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var typedArray = new Uint8Array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br></pre></td></tr></table></figure>\n<p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p>\n<p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p>\n<p>TypedArray数组也可以转换回普通数组。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> normalArray = <span class=\"type\">Array</span>.proto<span class=\"keyword\">type</span>.slice.call(typedArray);</span><br></pre></td></tr></table></figure>\n<h5 id=\"BYTES-PER-ELEMENT属性\"><a href=\"#BYTES-PER-ELEMENT属性\" class=\"headerlink\" title=\"BYTES_PER_ELEMENT属性\"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">Uint8Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">Int16Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\">Uint16Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\">Int32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Uint32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Float32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Float64Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ArrayBuffer与字符串的互相转换\"><a href=\"#ArrayBuffer与字符串的互相转换\" class=\"headerlink\" title=\"ArrayBuffer与字符串的互相转换\"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab2str</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode.apply(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转为ArrayBuffer对象，参数为字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">str2ab</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(str.length * <span class=\"number\">2</span>); <span class=\"comment\">// 每个字符占用2个字节</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bufView = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">    bufView[i] = str.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TypedArray-prototype-set\"><a href=\"#TypedArray-prototype-set\" class=\"headerlink\" title=\"TypedArray.prototype.set()\"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a);</span><br></pre></td></tr></table></figure>\n<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>\n<h5 id=\"TypedArray-prototype-subarray\"><a href=\"#TypedArray-prototype-subarray\" class=\"headerlink\" title=\"TypedArray.prototype.subarray()\"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.subarray(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.byteLength <span class=\"comment\">// 16</span></span><br><span class=\"line\">b.byteLength <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>\n<h5 id=\"TypedArray-prototype-slice\"><a href=\"#TypedArray-prototype-slice\" class=\"headerlink\" title=\"TypedArray.prototype.slice()\"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ui8 = Uint8Array.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ui8.slice(<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// Uint8Array [ 2 ]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p>\n<p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p>\n<h5 id=\"TypedArray-of\"><a href=\"#TypedArray-of\" class=\"headerlink\" title=\"TypedArray.of()\"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Float32Array.of(<span class=\"number\">0.151</span>, <span class=\"number\">-8</span>, <span class=\"number\">3.7</span>)</span><br><span class=\"line\"><span class=\"comment\">// Float32Array [ 0.151, -8, 3.7 ]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"TypedArray-from\"><a href=\"#TypedArray-from\" class=\"headerlink\" title=\"TypedArray.from()\"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Uint16Array.from([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"comment\">// Uint16Array [ 0, 1, 2 ]</span></span><br></pre></td></tr></table></figure>\n<p>这个方法还可以将一种TypedArray实例，转为另一种。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ui16 = <span class=\"built_in\">Uint16Array</span>.from(<span class=\"built_in\">Uint8Array</span>.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">ui16 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint16Array</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array.of(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>).map(x =&gt; <span class=\"number\">2</span> * x)</span><br><span class=\"line\"><span class=\"comment\">// Int8Array [ -2, -4, -6 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Int16Array.from(Int8Array.of(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>), x =&gt; <span class=\"number\">2</span> * x)</span><br><span class=\"line\"><span class=\"comment\">// Int16Array [ 254, 252, 250 ]</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p>\n<h4 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>\n<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>\n<p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataView(ArrayBuffer buffer <span class=\"comment\">[, 字节起始位置 <span class=\"comment\">[, 长度]</span>]</span>);</span><br></pre></td></tr></table></figure>\n<p>下面是一个例子。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br></pre></td></tr></table></figure>\n<p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p>\n<ul>\n<li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li>\n<li>DataView.prototype.byteLength：返回占据的内存字节长度</li>\n<li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li>\n</ul>\n<p>DataView实例提供8个方法读取内存。</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数。</li>\n<li>getUint8：读取1个字节，返回一个无符号的8位整数。</li>\n<li>getInt16：读取2个字节，返回一个16位整数。</li>\n<li>getUint16：读取2个字节，返回一个无符号的16位整数。</li>\n<li>getInt32：读取4个字节，返回一个32位整数。</li>\n<li>getUint32：读取4个字节，返回一个无符号的32位整数。</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数。</li>\n<li>getFloat64：读取8个字节，返回一个64位浮点数。</li>\n</ul>\n<p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第1个字节读取一个8位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = dv.getUint8(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第2个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = dv.getUint16(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第4个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = dv.getUint16(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>\n<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">1</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(1, true)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">2</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">3</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3)</span>;</span><br></pre></td></tr></table></figure>\n<p>DataView视图提供8个方法写入内存。</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数。</li>\n<li>setUint8：写入1个字节的8位无符号整数。</li>\n<li>setInt16：写入2个字节的16位整数。</li>\n<li>setUint16：写入2个字节的16位无符号整数。</li>\n<li>setInt32：写入4个字节的32位整数。</li>\n<li>setUint32：写入4个字节的32位无符号整数。</li>\n<li>setFloat32：写入4个字节的32位浮点数。</li>\n<li>setFloat64：写入8个字节的64位浮点数。</li>\n</ul>\n<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在第1个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setInt32(<span class=\"number\">0</span>, <span class=\"number\">25</span>, false);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第5个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setInt32(<span class=\"number\">4</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></span><br><span class=\"line\">dv.setFloat32(<span class=\"number\">8</span>, <span class=\"number\">2.5</span>, true);</span><br></pre></td></tr></table></figure>\n<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> littleEndian = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer).setInt16(<span class=\"number\">0</span>, <span class=\"number\">256</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(buffer)[<span class=\"number\">0</span>] === <span class=\"number\">256</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>\n<p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p>\n<p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.addEventListener(<span class=\"string\">\"loadend\"</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// reader.result 包含转化为类型数组的blob</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure>\n<p>更多关于Blob的内容，请直接查看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"数据格式转换\"><a href=\"#数据格式转换\" class=\"headerlink\" title=\"数据格式转换\"></a>数据格式转换</h3><h4 id=\"String转Blob\"><a href=\"#String转Blob\" class=\"headerlink\" title=\"String转Blob\"></a>String转Blob</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串 转换成 Blob 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">\"Hello World!\"</span>], &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"string\">'text/plain'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"TypeArray转Blob\"><a href=\"#TypeArray转Blob\" class=\"headerlink\" title=\"TypeArray转Blob\"></a>TypeArray转Blob</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将 TypeArray  转换成 Blob 对象</span></span><br><span class=\"line\">var array = new Uint16Array([<span class=\"number\">97</span>, <span class=\"number\">32</span>, <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">119</span>, <span class=\"number\">111</span>, <span class=\"number\">114</span>, <span class=\"number\">108</span>, <span class=\"number\">100</span>, <span class=\"number\">33</span>]);</span><br><span class=\"line\"><span class=\"comment\">//测试成功</span></span><br><span class=\"line\"><span class=\"comment\">//var blob = new Blob([array], &#123; type: \"application/octet-binary\" &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//测试成功， 注意必须[]的包裹</span></span><br><span class=\"line\">var blob = new Blob([array]);</span><br><span class=\"line\"><span class=\"comment\">//将 Blob对象 读成字符串</span></span><br><span class=\"line\">var reader = new FileReader();</span><br><span class=\"line\">reader.readAsText(blob, 'utf<span class=\"number\">-8</span>');</span><br><span class=\"line\">reader.onload = function (e) &#123;</span><br><span class=\"line\">    console.info(reader.result); <span class=\"comment\">//a Hello world!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ArrayBuffer转Blob\"><a href=\"#ArrayBuffer转Blob\" class=\"headerlink\" title=\"ArrayBuffer转Blob\"></a>ArrayBuffer转Blob</h4><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> <span class=\"type\">Blob</span>([buffer]);       <span class=\"comment\">// 注意必须包裹[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob转String\"><a href=\"#Blob转String\" class=\"headerlink\" title=\"Blob转String\"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">'中文字符串'</span>], &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成字符串</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsText(blob, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob转ArrayBuffer\"><a href=\"#Blob转ArrayBuffer\" class=\"headerlink\" title=\"Blob转ArrayBuffer\"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">'中文字符串'</span>], &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成 ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//ArrayBuffer &#123;&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span></span><br><span class=\"line\">    <span class=\"comment\">//var buf = new int16array(reader.result);</span></span><br><span class=\"line\">    <span class=\"comment\">//console.info(buf);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//DataView &#123;&#125;</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>目前在一个项目中，WebSocket部分由于后端使用了gzip压缩，前端处理起来废了一点时间，从而发现自己在二进制数据类型这个知识点还存在一定的盲区，因此这里进行总结。</p>\n</blockquote>\n<p>本文主要简单介绍ArrayBuffer对象、TypedArray对象、DataView对象以及Blob原始数据类型，和它们之间的互相转换方法。部分代码参考<a href=\"http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc4\" target=\"_blank\" rel=\"noopener\">这里</a>而非本人原创，仅做个人学习使用。</p>\n<p>这些类型化对象，一般会在以下场景中使用：</p>\n<ul>\n<li>WebGL 中，浏览器和显卡之间需要使用二进制数据进行通信。</li>\n<li>在一些 Rest 接口或者 WebSocket 中，采用压缩过的数据进行通信，这个压缩和解压缩的过程可能需要借助二进制对象。</li>\n<li>在 Canvas 中，我们可能需要通过生成 Blob 的方式保存当前内容。</li>\n<li>在 Img 等资源文件中，URL 可以为 Blob 原始数据类型。</li>\n<li>在读取用户上传文件时，可能需要用到二进制数据类型进行中间转换。</li>\n</ul>\n<p>下文分两部分，前一部分概述各个二进制数据类型，后一部分将它们之间的互相转换。</p>\n<h3 id=\"二进制数据类型概述\"><a href=\"#二进制数据类型概述\" class=\"headerlink\" title=\"二进制数据类型概述\"></a>二进制数据类型概述</h3><h4 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h4><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>\n<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。</p>\n<p>为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dataView = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buf);</span><br><span class=\"line\">dataView.getUint8(<span class=\"number\">0</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p>\n<p>另外，我们可以将ArrayBuffer生成的结果，传入TypedArray中：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(buffer);</span><br><span class=\"line\">x1[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(buffer);</span><br><span class=\"line\">x2[<span class=\"number\">0</span>]  = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x1[<span class=\"number\">0</span>] <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"built_in\">buffer</span> = <span class=\"keyword\">new</span> ArrayBuffer(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"built_in\">buffer</span>.byteLength</span><br><span class=\"line\"><span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">if</span> (<span class=\"built_in\">buffer</span>.byteLength === n) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 成功</span></span><br><span class=\"line\">&#125; <span class=\"built_in\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 失败</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Buffer</span> = buffer.slice(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。</p>\n<p>slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>\n<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>\n<p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"built_in\">ArrayBuffer</span>.isView(buffer) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>(buffer);</span><br><span class=\"line\"><span class=\"built_in\">ArrayBuffer</span>.isView(v) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h4><p>目前，TypedArray对象一共提供9种类型的视图，每一种视图都是一种构造函数。</p>\n<ul>\n<li>Int8Array：8位有符号整数，长度1个字节。</li>\n<li>Uint8Array：8位无符号整数，长度1个字节。</li>\n<li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li>\n<li>Int16Array：16位有符号整数，长度2个字节。</li>\n<li>Uint16Array：16位无符号整数，长度2个字节。</li>\n<li>Int32Array：32位有符号整数，长度4个字节。</li>\n<li>Uint32Array：32位无符号整数，长度4个字节。</li>\n<li>Float32Array：32位浮点数，长度4个字节。</li>\n<li>Float64Array：64位浮点数，长度8个字节。</li>\n</ul>\n<p>这9个构造函数生成的对象，统称为TypedArray对象。它们很像正常数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的方法，在类型化数组上面都能使用。两者的差异主要在以下方面。</p>\n<ul>\n<li>TypedArray数组的所有成员，都是同一种类型和格式。</li>\n<li>TypedArray数组的成员是连续的，不会有空位。</li>\n<li>Typed化数组成员的默认值为0。比如，new Array(10)返回一个正常数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个类型化数组，里面10个成员都是0。</li>\n<li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>\n</ul>\n<h5 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h5><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。</p>\n<p>构造函数有多种用法。</p>\n<ul>\n<li>TypedArray(buffer, byteOffset=0, length?)</li>\n</ul>\n<p>同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个8字节的ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = <span class=\"keyword\">new</span> <span class=\"type\">Int32Array</span>(b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(b, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(b, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>对于以上代码，v1、v2和v3是重叠的：v1[0]是一个32位整数，指向字节0～字节3；v2[0]是一个8位无符号整数，指向字节2；v3[0]是一个16位整数，指向字节2～字节3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>\n<p>注意，byteOffset必须与所要建立的数据类型一致，否则会报错。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> i16 = <span class=\"keyword\">new</span> <span class=\"type\">Int16Array</span>(buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，新生成一个8个字节的ArrayBuffer对象，然后在这个对象的第一个字节，建立带符号的16位整数视图，结果报错。因为，带符号的16位整数需要两个字节，所以byteOffset参数必须能够被2整除。</p>\n<p>如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式。</p>\n<ul>\n<li>TypedArray(length)</li>\n</ul>\n<p>视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f64a = new Float64Array(<span class=\"number\">8</span>);</span><br><span class=\"line\">f64a[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\">f64a[<span class=\"number\">1</span>] = <span class=\"number\">20</span>;</span><br><span class=\"line\">f64a[<span class=\"number\">2</span>] = f64a[<span class=\"number\">0</span>] + f64a[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>TypedArray(typedArray)</li>\n</ul>\n<p>类型化数组的构造函数，可以接受另一个视图实例作为参数。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typedArray = <span class=\"keyword\">new</span> <span class=\"type\">Int8Array</span>(<span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">4</span>));</span><br></pre></td></tr></table></figure>\n<p>上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p>\n<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = new Int8Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\">var y = new Int8Array(x);</span><br><span class=\"line\">x[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。</p>\n<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = new Int8Array([<span class=\"number\">1</span>, <span class=\"number\">1</span>]);</span><br><span class=\"line\">var y = new Int8Array(x.buffer);</span><br><span class=\"line\">x[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">0</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">y[<span class=\"number\">0</span>] <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>TypedArray(arrayLikeObject)</li>\n</ul>\n<p>构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var typedArray = new Uint8Array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br></pre></td></tr></table></figure>\n<p>注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p>\n<p>上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。</p>\n<p>TypedArray数组也可以转换回普通数组。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">var</span> normalArray = <span class=\"type\">Array</span>.proto<span class=\"keyword\">type</span>.slice.call(typedArray);</span><br></pre></td></tr></table></figure>\n<h5 id=\"BYTES-PER-ELEMENT属性\"><a href=\"#BYTES-PER-ELEMENT属性\" class=\"headerlink\" title=\"BYTES_PER_ELEMENT属性\"></a>BYTES_PER_ELEMENT属性</h5><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">Uint8Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 1</span></span><br><span class=\"line\">Int16Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\">Uint16Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\">Int32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Uint32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Float32Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 4</span></span><br><span class=\"line\">Float64Array<span class=\"selector-class\">.BYTES_PER_ELEMENT</span> <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"ArrayBuffer与字符串的互相转换\"><a href=\"#ArrayBuffer与字符串的互相转换\" class=\"headerlink\" title=\"ArrayBuffer与字符串的互相转换\"></a>ArrayBuffer与字符串的互相转换</h5><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayBuffer转为字符串，参数为ArrayBuffer对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab2str</span>(<span class=\"params\">buf</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode.apply(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串转为ArrayBuffer对象，参数为字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">str2ab</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(str.length * <span class=\"number\">2</span>); <span class=\"comment\">// 每个字符占用2个字节</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bufView = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint16Array</span>(buf);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, strLen = str.length; i &lt; strLen; i++) &#123;</span><br><span class=\"line\">    bufView[i] = str.charCodeAt(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TypedArray-prototype-set\"><a href=\"#TypedArray-prototype-set\" class=\"headerlink\" title=\"TypedArray.prototype.set()\"></a>TypedArray.prototype.set()</h5><p>TypedArray数组的set方法用于复制数组（正常数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint8Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a);</span><br></pre></td></tr></table></figure>\n<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。set方法还可以接受第二个参数，表示从b对象哪一个成员开始复制a对象。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b.<span class=\"keyword\">set</span>(a, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>\n<h5 id=\"TypedArray-prototype-subarray\"><a href=\"#TypedArray-prototype-subarray\" class=\"headerlink\" title=\"TypedArray.prototype.subarray()\"></a>TypedArray.prototype.subarray()</h5><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"type\">Uint16Array</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.subarray(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a.byteLength <span class=\"comment\">// 16</span></span><br><span class=\"line\">b.byteLength <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>\n<h5 id=\"TypedArray-prototype-slice\"><a href=\"#TypedArray-prototype-slice\" class=\"headerlink\" title=\"TypedArray.prototype.slice()\"></a>TypedArray.prototype.slice()</h5><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ui8 = Uint8Array.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">ui8.slice(<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// Uint8Array [ 2 ]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p>\n<p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p>\n<h5 id=\"TypedArray-of\"><a href=\"#TypedArray-of\" class=\"headerlink\" title=\"TypedArray.of()\"></a>TypedArray.of()</h5><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Float32Array.of(<span class=\"number\">0.151</span>, <span class=\"number\">-8</span>, <span class=\"number\">3.7</span>)</span><br><span class=\"line\"><span class=\"comment\">// Float32Array [ 0.151, -8, 3.7 ]</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"TypedArray-from\"><a href=\"#TypedArray-from\" class=\"headerlink\" title=\"TypedArray.from()\"></a>TypedArray.from()</h5><p>静态方法from接受一个<strong>可遍历的数据结构（比如数组）</strong>作为参数，返回一个基于这个结构的TypedArray实例。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Uint16Array.from([<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"comment\">// Uint16Array [ 0, 1, 2 ]</span></span><br></pre></td></tr></table></figure>\n<p>这个方法还可以将一种TypedArray实例，转为另一种。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ui16 = <span class=\"built_in\">Uint16Array</span>.from(<span class=\"built_in\">Uint8Array</span>.of(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">ui16 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Uint16Array</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array.of(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>).map(x =&gt; <span class=\"number\">2</span> * x)</span><br><span class=\"line\"><span class=\"comment\">// Int8Array [ -2, -4, -6 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Int16Array.from(Int8Array.of(<span class=\"number\">127</span>, <span class=\"number\">126</span>, <span class=\"number\">125</span>), x =&gt; <span class=\"number\">2</span> * x)</span><br><span class=\"line\"><span class=\"comment\">// Int16Array [ 254, 252, 250 ]</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子中，from方法没有发生溢出，这说明遍历是针对新生成的16位整数数组，而不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中（占用内存从3字节变为6字节），然后再进行处理。</p>\n<h4 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h4><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。</p>\n<p>DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>\n<p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DataView(ArrayBuffer buffer <span class=\"comment\">[, 字节起始位置 <span class=\"comment\">[, 长度]</span>]</span>);</span><br></pre></td></tr></table></figure>\n<p>下面是一个例子。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br></pre></td></tr></table></figure>\n<p>DataView实例有以下属性，含义与TypedArray实例的同名方法相同。</p>\n<ul>\n<li>DataView.prototype.buffer：返回对应的ArrayBuffer对象</li>\n<li>DataView.prototype.byteLength：返回占据的内存字节长度</li>\n<li>DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始</li>\n</ul>\n<p>DataView实例提供8个方法读取内存。</p>\n<ul>\n<li>getInt8：读取1个字节，返回一个8位整数。</li>\n<li>getUint8：读取1个字节，返回一个无符号的8位整数。</li>\n<li>getInt16：读取2个字节，返回一个16位整数。</li>\n<li>getUint16：读取2个字节，返回一个无符号的16位整数。</li>\n<li>getInt32：读取4个字节，返回一个32位整数。</li>\n<li>getUint32：读取4个字节，返回一个无符号的32位整数。</li>\n<li>getFloat32：读取4个字节，返回一个32位浮点数。</li>\n<li>getFloat64：读取8个字节，返回一个64位浮点数。</li>\n</ul>\n<p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dv = <span class=\"keyword\">new</span> <span class=\"type\">DataView</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第1个字节读取一个8位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v1 = dv.getUint8(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第2个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = dv.getUint16(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第4个字节读取一个16位无符号整数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v3 = dv.getUint16(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>\n<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 小端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">1</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(1, true)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">2</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3, false)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 大端字节序</span></span><br><span class=\"line\">var v<span class=\"number\">3</span> = dv.getUi<span class=\"symbol\">nt16</span><span class=\"comment\">(3)</span>;</span><br></pre></td></tr></table></figure>\n<p>DataView视图提供8个方法写入内存。</p>\n<ul>\n<li>setInt8：写入1个字节的8位整数。</li>\n<li>setUint8：写入1个字节的8位无符号整数。</li>\n<li>setInt16：写入2个字节的16位整数。</li>\n<li>setUint16：写入2个字节的16位无符号整数。</li>\n<li>setInt32：写入4个字节的32位整数。</li>\n<li>setUint32：写入4个字节的32位无符号整数。</li>\n<li>setFloat32：写入4个字节的32位浮点数。</li>\n<li>setFloat64：写入8个字节的64位浮点数。</li>\n</ul>\n<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在第1个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setInt32(<span class=\"number\">0</span>, <span class=\"number\">25</span>, false);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第5个字节，以大端字节序写入值为25的32位整数</span></span><br><span class=\"line\">dv.setInt32(<span class=\"number\">4</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></span><br><span class=\"line\">dv.setFloat32(<span class=\"number\">8</span>, <span class=\"number\">2.5</span>, true);</span><br></pre></td></tr></table></figure>\n<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> littleEndian = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer).setInt16(<span class=\"number\">0</span>, <span class=\"number\">256</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(buffer)[<span class=\"number\">0</span>] === <span class=\"number\">256</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>\n<p>要从其他非blob对象和数据构造一个Blob，请使用 Blob() 构造函数。要创建包含另一个blob数据的子集blob，请使用 slice()方法。要获取用户文件系统上的文件对应的Blob对象，请参阅 File文档。</p>\n<p>从Blob中读取内容的唯一方法是使用 FileReader。以下代码将 Blob 的内容作为类型数组读取：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.addEventListener(<span class=\"string\">\"loadend\"</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// reader.result 包含转化为类型数组的blob</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br></pre></td></tr></table></figure>\n<p>更多关于Blob的内容，请直接查看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"数据格式转换\"><a href=\"#数据格式转换\" class=\"headerlink\" title=\"数据格式转换\"></a>数据格式转换</h3><h4 id=\"String转Blob\"><a href=\"#String转Blob\" class=\"headerlink\" title=\"String转Blob\"></a>String转Blob</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串 转换成 Blob 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">\"Hello World!\"</span>], &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span>: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.info(blob.slice(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"string\">'text/plain'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"TypeArray转Blob\"><a href=\"#TypeArray转Blob\" class=\"headerlink\" title=\"TypeArray转Blob\"></a>TypeArray转Blob</h4><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将 TypeArray  转换成 Blob 对象</span></span><br><span class=\"line\">var array = new Uint16Array([<span class=\"number\">97</span>, <span class=\"number\">32</span>, <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">32</span>, <span class=\"number\">119</span>, <span class=\"number\">111</span>, <span class=\"number\">114</span>, <span class=\"number\">108</span>, <span class=\"number\">100</span>, <span class=\"number\">33</span>]);</span><br><span class=\"line\"><span class=\"comment\">//测试成功</span></span><br><span class=\"line\"><span class=\"comment\">//var blob = new Blob([array], &#123; type: \"application/octet-binary\" &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">//测试成功， 注意必须[]的包裹</span></span><br><span class=\"line\">var blob = new Blob([array]);</span><br><span class=\"line\"><span class=\"comment\">//将 Blob对象 读成字符串</span></span><br><span class=\"line\">var reader = new FileReader();</span><br><span class=\"line\">reader.readAsText(blob, 'utf<span class=\"number\">-8</span>');</span><br><span class=\"line\">reader.onload = function (e) &#123;</span><br><span class=\"line\">    console.info(reader.result); <span class=\"comment\">//a Hello world!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ArrayBuffer转Blob\"><a href=\"#ArrayBuffer转Blob\" class=\"headerlink\" title=\"ArrayBuffer转Blob\"></a>ArrayBuffer转Blob</h4><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> <span class=\"type\">ArrayBuffer</span>(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> <span class=\"type\">Blob</span>([buffer]);       <span class=\"comment\">// 注意必须包裹[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob转String\"><a href=\"#Blob转String\" class=\"headerlink\" title=\"Blob转String\"></a>Blob转String</h4><p>这里需要注意的是readAsText方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">'中文字符串'</span>], &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成字符串</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsText(blob, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Blob转ArrayBuffer\"><a href=\"#Blob转ArrayBuffer\" class=\"headerlink\" title=\"Blob转ArrayBuffer\"></a>Blob转ArrayBuffer</h4><p>这里需要注意的是readAsArrayBuffer方法的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串转换成 Blob对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> blob = <span class=\"keyword\">new</span> Blob([<span class=\"string\">'中文字符串'</span>], &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'text/plain'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//将Blob 对象转换成 ArrayBuffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">reader.readAsArrayBuffer(blob);</span><br><span class=\"line\">reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//ArrayBuffer &#123;&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//经常会遇到的异常 Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span></span><br><span class=\"line\">    <span class=\"comment\">//var buf = new int16array(reader.result);</span></span><br><span class=\"line\">    <span class=\"comment\">//console.info(buf);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//[228, 184, 173, 230, 150, 135, 229, 173, 151, 231, 172, 166, 228, 184, 178]</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将 ArrayBufferView  转换成Blob</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(reader.result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.info(buf); <span class=\"comment\">//DataView &#123;&#125;</span></span><br><span class=\"line\">    reader.readAsText(<span class=\"keyword\">new</span> Blob([buf]), <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    reader.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.info(reader.result); <span class=\"comment\">//中文字符串</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"构建利用Proxy和Reflect实现双向数据绑定的微框架","date":"2018-04-09T06:40:44.000Z","_content":">写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。\n\n代码下载地址：[这里下载](https://github.com/aircloud/Polar.js)\n\n### 综述\n\n*关于Proxy和Reflect的资料推荐阮老师的教程:http://es6.ruanyifeng.com/ 这里不做过多介绍。*\n\n实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。\n\n由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。\n\n首先我们可以看整体功能演示：  \n[一个gif动图，如果不能看，请点击[这里的链接](https://www.10000h.top/images/data_img/gif1.gif)]\n\n![](https://www.10000h.top/images/data_img/gif1.gif)\n\n### 代码分析\n\n我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。\n\n我的思路是这样的：\n\n* 将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。\n* 对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。\n* 我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。\n\n下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:\n\n```\n<div id=\"app\">\n    <form>\n        <label>name:</label>\n        <input p-model = \"name\" />\n    </form>\n    <div>name:{{name}} age:{{age}}</div>\n    <i>note:{{note}}</i><br/>\n    <button p-click=\"test(2)\">button1</button>\n</div>\n<script>\n var myPolar = new Polar({\n        el:\"#app\",\n        data: {\n            name: \"niexiaotao\",\n            age:16,\n            note:\"Student of Zhejiang University\"\n        },\n        methods:{\n            test:function(e,addNumber){\n                console.log(\"e:\",e);\n                this.data.age+=Number(addNumber);\n            }\n        }\n});\n</script>\n```\n\n没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。\n\n我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:\n\n```\n constructor(configs){\n        this.root = this.el = document.querySelector(configs.el);\n        this._data = configs.data;\n        this._data.__bindings = {};\n        //创建代理对象\n        this.data = new Proxy(this._data, {set});\n        this.methods = configs.methods;\n\n        this._compile(this.root);\n}\n```\n\n这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的`_compile`方法可以理解为一个私有的初始化方法。\n\n实际上我把剩下的内容几乎都放在`_compile`方法里面了，这样理解起来方便，但是之后可能要改动。\n\n我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：\n\n假设我们这样`<div>name:{{name}}</div>`将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。\n\n看上文的`__bindings`。这个对象用来存储所有绑定的dom节点信息，`__bindings`本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：\n\n```\ndataSet.__bindings[key].forEach(function(item){\n       //do something to update...\n});\n```\n\n我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：\n\n```\nfunction Directive(el,polar,attr,elementValue){\n    this.el=el;//元素本身dom节点\n    this.polar = polar;//对应的polar实例\n    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue\n    this.el[this.attr] = this.elementValue = elementValue;//初始化\n}\n```\n\n这样，我们的set可以这样写:\n\n```\nfunction set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    var dataSet = receiver || target;\n    dataSet.__bindings[key].forEach(function(item){\n        item.el[item.attr] = item.elementValue = value;\n    });\n    return result;\n}\n```\n\n接下来可能还有一个问题：我们的`{{name}}`实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：`<div>name:{{name}} age:{{age}}</div>`？\n\n关于这两个问题，前者的答案是我们将`{{name}}`替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)\n\n所以我们在`_compile`函数首先：\n\n```\nvar _this = this;\n\n        var nodes = root.children;\n\n        var bindDataTester = new RegExp(\"{{(.*?)}}\",\"ig\");\n\n        for(let i=0;i<nodes.length;i++){\n            var node=nodes[i];\n\n            //如果还有html字节点，则递归\n            if(node.children.length){\n                this._compile(node);\n            }\n\n            var matches = node.innerHTML.match(bindDataTester);\n            if(matches){\n                var newMatches = matches.map(function (item) {\n                    return  item.replace(/{{(.*?)}}/,\"$1\")\n                });\n                var splitTextNodes  = node.innerHTML.split(/{{.*?}}/);\n                node.innerHTML=null;\n                //更新DOM，处理同一个textnode里面多次绑定情况\n                if(splitTextNodes[0]){\n                    node.append(document.createTextNode(splitTextNodes[0]));\n                }\n                for(let ii=0;ii<newMatches.length;ii++){\n                    var el = document.createTextNode('');\n                    node.appendChild(el);\n                    if(splitTextNodes[ii+1]){\n                        node.append(document.createTextNode(splitTextNodes[ii+1]));\n                    }\n                //对数据和dom进行绑定\n                let returnCode = !this._data.__bindings[newMatches[ii]]?\n                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]])]\n                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]]))\n                }\n            }\n\n```\n\n这样，我们的数据绑定阶段就写好了，接下来，我们处理`<input p-model = \"name\" />`这样的情况。\n\n这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：\n\n```\nif(node.hasAttribute((\"p-model\"))\n                && node.tagName.toLocaleUpperCase()==\"INPUT\" || node.tagName.toLocaleUpperCase()==\"TEXTAREA\"){\n                node.addEventListener(\"input\", (function () {\n\n                    var attributeValue = node.getAttribute(\"p-model\");\n\n                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,\"value\",_this.data[attributeValue])) ;\n                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,\"value\",_this.data[attributeValue])];\n\n                    return function (event) {\n                        _this.data[attributeValue]=event.target.value\n                    }\n                })());\n}\n```\n\n请注意，上面调用了一个`IIFE`，实际绑定的函数只有返回的函数那一小部分。\n\n最后我们处理事件的情况：`<button p-click=\"test(2)\">button1</button>`\n\n实际上这比处理`p-model`还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将`event`始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。\n\n```\nif(node.hasAttribute(\"p-click\")) {\n                node.addEventListener(\"click\",function(){\n                    var attributeValue=node.getAttribute(\"p-click\");\n                    var args=/\\(.*\\)/.exec(attributeValue);\n                    //允许参数\n                    if(args) {\n                        args=args[0];\n                        attributeValue=attributeValue.replace(args,\"\");\n                        args=args.replace(/[\\(\\)\\'\\\"]/g,'').split(\",\");\n                    }\n                    else args=[];\n                    return function (event) {\n                        _this.methods[attributeValue].apply(_this,[event,...args]);\n                    }\n                }());\n}\n```\n\n现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在[这里下载](https://github.com/aircloud/Polar.js)。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。\n\n一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～\n\n---\n\n\n最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。","source":"_posts/构建利用Proxy和Reflect实现双向数据绑定的微框架.md","raw":"---\ntitle: 构建利用Proxy和Reflect实现双向数据绑定的微框架\ndate: 2018-04-09 14:40:44\ntags:\n    - MVVM\n---\n>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。\n\n代码下载地址：[这里下载](https://github.com/aircloud/Polar.js)\n\n### 综述\n\n*关于Proxy和Reflect的资料推荐阮老师的教程:http://es6.ruanyifeng.com/ 这里不做过多介绍。*\n\n实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。\n\n由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。\n\n首先我们可以看整体功能演示：  \n[一个gif动图，如果不能看，请点击[这里的链接](https://www.10000h.top/images/data_img/gif1.gif)]\n\n![](https://www.10000h.top/images/data_img/gif1.gif)\n\n### 代码分析\n\n我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。\n\n我的思路是这样的：\n\n* 将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。\n* 对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。\n* 我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。\n\n下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:\n\n```\n<div id=\"app\">\n    <form>\n        <label>name:</label>\n        <input p-model = \"name\" />\n    </form>\n    <div>name:{{name}} age:{{age}}</div>\n    <i>note:{{note}}</i><br/>\n    <button p-click=\"test(2)\">button1</button>\n</div>\n<script>\n var myPolar = new Polar({\n        el:\"#app\",\n        data: {\n            name: \"niexiaotao\",\n            age:16,\n            note:\"Student of Zhejiang University\"\n        },\n        methods:{\n            test:function(e,addNumber){\n                console.log(\"e:\",e);\n                this.data.age+=Number(addNumber);\n            }\n        }\n});\n</script>\n```\n\n没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。\n\n我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:\n\n```\n constructor(configs){\n        this.root = this.el = document.querySelector(configs.el);\n        this._data = configs.data;\n        this._data.__bindings = {};\n        //创建代理对象\n        this.data = new Proxy(this._data, {set});\n        this.methods = configs.methods;\n\n        this._compile(this.root);\n}\n```\n\n这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的`_compile`方法可以理解为一个私有的初始化方法。\n\n实际上我把剩下的内容几乎都放在`_compile`方法里面了，这样理解起来方便，但是之后可能要改动。\n\n我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：\n\n假设我们这样`<div>name:{{name}}</div>`将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。\n\n看上文的`__bindings`。这个对象用来存储所有绑定的dom节点信息，`__bindings`本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：\n\n```\ndataSet.__bindings[key].forEach(function(item){\n       //do something to update...\n});\n```\n\n我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：\n\n```\nfunction Directive(el,polar,attr,elementValue){\n    this.el=el;//元素本身dom节点\n    this.polar = polar;//对应的polar实例\n    this.attr = attr;//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue\n    this.el[this.attr] = this.elementValue = elementValue;//初始化\n}\n```\n\n这样，我们的set可以这样写:\n\n```\nfunction set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    var dataSet = receiver || target;\n    dataSet.__bindings[key].forEach(function(item){\n        item.el[item.attr] = item.elementValue = value;\n    });\n    return result;\n}\n```\n\n接下来可能还有一个问题：我们的`{{name}}`实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：`<div>name:{{name}} age:{{age}}</div>`？\n\n关于这两个问题，前者的答案是我们将`{{name}}`替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)\n\n所以我们在`_compile`函数首先：\n\n```\nvar _this = this;\n\n        var nodes = root.children;\n\n        var bindDataTester = new RegExp(\"{{(.*?)}}\",\"ig\");\n\n        for(let i=0;i<nodes.length;i++){\n            var node=nodes[i];\n\n            //如果还有html字节点，则递归\n            if(node.children.length){\n                this._compile(node);\n            }\n\n            var matches = node.innerHTML.match(bindDataTester);\n            if(matches){\n                var newMatches = matches.map(function (item) {\n                    return  item.replace(/{{(.*?)}}/,\"$1\")\n                });\n                var splitTextNodes  = node.innerHTML.split(/{{.*?}}/);\n                node.innerHTML=null;\n                //更新DOM，处理同一个textnode里面多次绑定情况\n                if(splitTextNodes[0]){\n                    node.append(document.createTextNode(splitTextNodes[0]));\n                }\n                for(let ii=0;ii<newMatches.length;ii++){\n                    var el = document.createTextNode('');\n                    node.appendChild(el);\n                    if(splitTextNodes[ii+1]){\n                        node.append(document.createTextNode(splitTextNodes[ii+1]));\n                    }\n                //对数据和dom进行绑定\n                let returnCode = !this._data.__bindings[newMatches[ii]]?\n                    this._data.__bindings[newMatches[ii]] = [new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]])]\n                    :this._data.__bindings[newMatches[ii]].push(new Directive(el,this,\"nodeValue\",this.data[newMatches[ii]]))\n                }\n            }\n\n```\n\n这样，我们的数据绑定阶段就写好了，接下来，我们处理`<input p-model = \"name\" />`这样的情况。\n\n这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：\n\n```\nif(node.hasAttribute((\"p-model\"))\n                && node.tagName.toLocaleUpperCase()==\"INPUT\" || node.tagName.toLocaleUpperCase()==\"TEXTAREA\"){\n                node.addEventListener(\"input\", (function () {\n\n                    var attributeValue = node.getAttribute(\"p-model\");\n\n                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(node,_this,\"value\",_this.data[attributeValue])) ;\n                    else _this._data.__bindings[attributeValue] = [new Directive(node,_this,\"value\",_this.data[attributeValue])];\n\n                    return function (event) {\n                        _this.data[attributeValue]=event.target.value\n                    }\n                })());\n}\n```\n\n请注意，上面调用了一个`IIFE`，实际绑定的函数只有返回的函数那一小部分。\n\n最后我们处理事件的情况：`<button p-click=\"test(2)\">button1</button>`\n\n实际上这比处理`p-model`还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将`event`始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。\n\n```\nif(node.hasAttribute(\"p-click\")) {\n                node.addEventListener(\"click\",function(){\n                    var attributeValue=node.getAttribute(\"p-click\");\n                    var args=/\\(.*\\)/.exec(attributeValue);\n                    //允许参数\n                    if(args) {\n                        args=args[0];\n                        attributeValue=attributeValue.replace(args,\"\");\n                        args=args.replace(/[\\(\\)\\'\\\"]/g,'').split(\",\");\n                    }\n                    else args=[];\n                    return function (event) {\n                        _this.methods[attributeValue].apply(_this,[event,...args]);\n                    }\n                }());\n}\n```\n\n现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在[这里下载](https://github.com/aircloud/Polar.js)。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。\n\n一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～\n\n---\n\n\n最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。","slug":"构建利用Proxy和Reflect实现双向数据绑定的微框架","published":1,"updated":"2020-02-17T12:50:55.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o500088zom2a8qfby7","content":"<blockquote>\n<p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p>\n</blockquote>\n<p>代码下载地址：<a href=\"https://github.com/aircloud/Polar.js\" target=\"_blank\" rel=\"noopener\">这里下载</a></p>\n<h3 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p>\n<p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p>\n<p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p>\n<p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href=\"https://www.10000h.top/images/data_img/gif1.gif\" target=\"_blank\" rel=\"noopener\">这里的链接</a>]</p>\n<p><img src=\"https://www.10000h.top/images/data_img/gif1.gif\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p>\n<p>我的思路是这样的：</p>\n<ul>\n<li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li>\n<li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li>\n<li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li>\n</ul>\n<p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">p-model</span> = <span class=\"string\">\"name\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>name:</span><span class=\"template-variable\">&#123;&#123;name&#125;&#125;</span><span class=\"xml\"> age:</span><span class=\"template-variable\">&#123;&#123;age&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>note:</span><span class=\"template-variable\">&#123;&#123;note&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">p-click</span>=<span class=\"string\">\"test(2)\"</span>&gt;</span>button1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"xml\"> var myPolar = new Polar(&#123;</span></span><br><span class=\"line\"><span class=\"xml\">        el:\"#app\",</span></span><br><span class=\"line\"><span class=\"xml\">        data: &#123;</span></span><br><span class=\"line\"><span class=\"xml\">            name: \"niexiaotao\",</span></span><br><span class=\"line\"><span class=\"xml\">            age:16,</span></span><br><span class=\"line\"><span class=\"xml\">            note:\"Student of Zhejiang University\"</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;,</span></span><br><span class=\"line\"><span class=\"xml\">        methods:&#123;</span></span><br><span class=\"line\"><span class=\"xml\">            test:function(e,addNumber)&#123;</span></span><br><span class=\"line\"><span class=\"xml\">                console.log(\"e:\",e);</span></span><br><span class=\"line\"><span class=\"xml\">                this.data.age+=Number(addNumber);</span></span><br><span class=\"line\"><span class=\"xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;);</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p>\n<p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">constructor</span>(configs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.el = document.querySelector(configs.el);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data = configs.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data.__bindings = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = new Proxy(<span class=\"keyword\">this</span>._data, &#123;<span class=\"keyword\">set</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methods = configs.methods;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._compile(<span class=\"keyword\">this</span>.root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p>\n<p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p>\n<p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p>\n<p>假设我们这样<code>&lt;div&gt;name:&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p>\n<p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataSet.__bindings[key].<span class=\"keyword\">forEach</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//do something to update...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el=el;<span class=\"comment\">//元素本身dom节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.polar = polar;<span class=\"comment\">//对应的polar实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.attr = attr;<span class=\"comment\">//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el[<span class=\"keyword\">this</span>.attr] = <span class=\"keyword\">this</span>.elementValue = elementValue;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们的set可以这样写:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> set(<span class=\"keyword\">target</span>, key, <span class=\"keyword\">value</span>, receiver) &#123;</span><br><span class=\"line\">    const result = Reflect.set(<span class=\"keyword\">target</span>, key, <span class=\"keyword\">value</span>, receiver);</span><br><span class=\"line\">    var dataSet = receiver || <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    dataSet.__bindings[key].forEach(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span></span>&#123;</span><br><span class=\"line\">        item.el[item.attr] = item.elementValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来可能还有一个问题：我们的<code></code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name: age:&lt;/div&gt;</code>？</p>\n<p>关于这两个问题，前者的答案是我们将<code></code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p>\n<p>所以我们在<code>_compile</code>函数首先：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> nodes = root.children;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindDataTester = <span class=\"keyword\">new</span> <span class=\"type\">RegExp</span>(<span class=\"string\">\"&#123;&#123;(.*?)&#125;&#125;\"</span>,<span class=\"string\">\"ig\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node=nodes[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还有html字节点，则递归</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children.length)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>._compile(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> matches = node.innerHTML.match(bindDataTester);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matches)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Matches</span> = matches.map(<span class=\"function\"><span class=\"keyword\">function</span> </span>(item) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,<span class=\"string\">\"$1\"</span>)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class=\"line\">                node.innerHTML=<span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//更新DOM，处理同一个textnode里面多次绑定情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(splitTextNodes[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                    node.append(document.createTextNode(splitTextNodes[<span class=\"number\">0</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(let ii=<span class=\"number\">0</span>;ii&lt;<span class=\"keyword\">new</span><span class=\"type\">Matches</span>.length;ii++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> el = document.createTextNode(<span class=\"string\">''</span>);</span><br><span class=\"line\">                    node.appendChild(el);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(splitTextNodes[ii+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                        node.append(document.createTextNode(splitTextNodes[ii+<span class=\"number\">1</span>]));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                <span class=\"comment\">//对数据和dom进行绑定</span></span><br><span class=\"line\">                let returnCode = !<span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]?</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]] = [<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">\"nodeValue\"</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]])]</span><br><span class=\"line\">                    :<span class=\"type\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]].push(<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">\"nodeValue\"</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p>\n<p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(<span class=\"keyword\">node</span>.<span class=\"title\">hasAttribute</span>((<span class=\"string\">\"p-model\"</span>))</span><br><span class=\"line\">                &amp;&amp; <span class=\"keyword\">node</span>.<span class=\"title\">tagName</span>.toLocaleUpperCase()==<span class=\"string\">\"INPUT\"</span> || <span class=\"keyword\">node</span>.<span class=\"title\">tagName</span>.toLocaleUpperCase()==<span class=\"string\">\"TEXTAREA\"</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">node</span>.<span class=\"title\">addEventListener</span>(<span class=\"string\">\"input\"</span>, (function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    var attributeValue = <span class=\"keyword\">node</span>.<span class=\"title\">getAttribute</span>(<span class=\"string\">\"p-model\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(<span class=\"keyword\">node</span><span class=\"title\">,_this</span>,<span class=\"string\">\"value\"</span>,_this.data[attributeValue])) ;</span><br><span class=\"line\">                    else _this._data.__bindings[attributeValue] = [new Directive(<span class=\"keyword\">node</span><span class=\"title\">,_this</span>,<span class=\"string\">\"value\"</span>,_this.data[attributeValue])];</span><br><span class=\"line\"></span><br><span class=\"line\">                    return function (event) &#123;</span><br><span class=\"line\">                        _this.data[attributeValue]=event.target.value</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p>\n<p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p>\n<p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.hasAttribute(<span class=\"string\">\"p-click\"</span>)) &#123;</span><br><span class=\"line\">                node.addEventListener(<span class=\"string\">\"click\"</span>,function()&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> attributeValue=node.getAttribute(<span class=\"string\">\"p-click\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"keyword\">args</span>=/\\(.*\\)/.exec(attributeValue);</span><br><span class=\"line\">                    <span class=\"comment\">//允许参数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">args</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>[0];</span><br><span class=\"line\">                        attributeValue=attributeValue.<span class=\"keyword\">replace</span>(<span class=\"keyword\">args</span>,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>.<span class=\"keyword\">replace</span>(/[\\(\\)\\'\\<span class=\"string\">\"]/g,'').split(\"</span>,\");</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">args</span>=[];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> function (event) &#123;</span><br><span class=\"line\">                        _this.methods[attributeValue].apply(_this,[event,...<span class=\"keyword\">args</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href=\"https://github.com/aircloud/Polar.js\" target=\"_blank\" rel=\"noopener\">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p>\n<p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p>\n<hr>\n<p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写在前面：这篇文章讲述了如何利用Proxy和Reflect实现双向数据绑定，个人系Vue早期玩家，写这个小框架的时候也没有参考Vue等源代码，之前了解过其他实现，但没有直接参考其他代码，如有雷同，纯属巧合。</p>\n</blockquote>\n<p>代码下载地址：<a href=\"https://github.com/aircloud/Polar.js\" target=\"_blank\" rel=\"noopener\">这里下载</a></p>\n<h3 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h3><p><em>关于Proxy和Reflect的资料推荐阮老师的教程:<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/</a> 这里不做过多介绍。</em></p>\n<p>实现双向数据绑定的方法有很多，也可以参考本专栏之前的其他实现，我之所以选择用Proxy和Reflect，一方面是因为可以大量节约代码，并且简化逻辑，可以让我把更多的经历放在其他内容的构建上面，另外一方面本项目直接基于ES6，用这些内容也符合面向未来的JS编程规范，第三点最后说。</p>\n<p>由于这个小框架是自己在PolarBear这个咖啡馆在一个安静的午后开始写成，暂且起名Polar，日后希望我能继续完善这个小框架，给添加上更多有趣的功能。</p>\n<p>首先我们可以看整体功能演示：<br>[一个gif动图，如果不能看，请点击<a href=\"https://www.10000h.top/images/data_img/gif1.gif\" target=\"_blank\" rel=\"noopener\">这里的链接</a>]</p>\n<p><img src=\"https://www.10000h.top/images/data_img/gif1.gif\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>我们要做这样一个小框架，核心是要监听数据的改变，并且在数据的改变的时候进行一些操作，从而维持数据的一致。</p>\n<p>我的思路是这样的：</p>\n<ul>\n<li>将所有的数据信息放在一个属性对象中(this._data),之后给这个属性对象用Proxy包装set,在代理函数中我们更新属性对象的具体内容，同时通知所有监听者，之后返回新的代理对象(this.data)，我们之后操作的都是新的代理对象。</li>\n<li>对于input等表单，我们需要监听input事件，在回调函数中直接设置我们代理好的数据对象，从而触发我们的代理函数。</li>\n<li>我们同时也应该支持事件机制，这里我们以最常用的click方法作为例子实现。</li>\n</ul>\n<p>下面开始第一部分，我们希望我们之后使用这个库的时候可以这样调用:</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span>name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">p-model</span> = <span class=\"string\">\"name\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>name:</span><span class=\"template-variable\">&#123;&#123;name&#125;&#125;</span><span class=\"xml\"> age:</span><span class=\"template-variable\">&#123;&#123;age&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span>note:</span><span class=\"template-variable\">&#123;&#123;note&#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">p-click</span>=<span class=\"string\">\"test(2)\"</span>&gt;</span>button1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"xml\"> var myPolar = new Polar(&#123;</span></span><br><span class=\"line\"><span class=\"xml\">        el:\"#app\",</span></span><br><span class=\"line\"><span class=\"xml\">        data: &#123;</span></span><br><span class=\"line\"><span class=\"xml\">            name: \"niexiaotao\",</span></span><br><span class=\"line\"><span class=\"xml\">            age:16,</span></span><br><span class=\"line\"><span class=\"xml\">            note:\"Student of Zhejiang University\"</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;,</span></span><br><span class=\"line\"><span class=\"xml\">        methods:&#123;</span></span><br><span class=\"line\"><span class=\"xml\">            test:function(e,addNumber)&#123;</span></span><br><span class=\"line\"><span class=\"xml\">                console.log(\"e:\",e);</span></span><br><span class=\"line\"><span class=\"xml\">                this.data.age+=Number(addNumber);</span></span><br><span class=\"line\"><span class=\"xml\">            &#125;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;);</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>没错，和Vue神似吧，所以这种调用方式应当为我们所熟悉。</p>\n<p>我们需要建立一个Polar类，这个类的构造函数应该进行一些初始化操作:</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">constructor</span>(configs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">this</span>.el = document.querySelector(configs.el);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data = configs.<span class=\"keyword\">data</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._data.__bindings = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">data</span> = new Proxy(<span class=\"keyword\">this</span>._data, &#123;<span class=\"keyword\">set</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methods = configs.methods;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._compile(<span class=\"keyword\">this</span>.root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里面的一部份内容是直接将我们传入的configs按照属性分别赋值，另外就是我们创建代理对象的过程，最后的<code>_compile</code>方法可以理解为一个私有的初始化方法。</p>\n<p>实际上我把剩下的内容几乎都放在<code>_compile</code>方法里面了，这样理解起来方便，但是之后可能要改动。</p>\n<p>我们还是先不能看我们代理的set该怎么写，因为这个时候我们还要先继续梳理思路：</p>\n<p>假设我们这样<code>&lt;div&gt;name:&lt;/div&gt;</code>将数据绑定到dom节点，这个时候我们需要做什么呢，或者说，我们通过什么方式让dom节点和数据对应起来，随着数据改变而改变。</p>\n<p>看上文的<code>__bindings</code>。这个对象用来存储所有绑定的dom节点信息，<code>__bindings</code>本身是一个对象，每一个有对应dom节点绑定的数据名称都是它的属性，对应一个数组，数组中的每一个内容都是一个绑定信息，这样，我们在自己写的set代理函数中，我们一个个调用过去，就可以更新内容了：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataSet.__bindings[key].<span class=\"keyword\">forEach</span>(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//do something to update...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我这里创建了一个用于构造调用的函数，这个函数用于创建存储绑定信息的对象：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Directive(el,polar,attr,elementValue)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el=el;<span class=\"comment\">//元素本身dom节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.polar = polar;<span class=\"comment\">//对应的polar实例</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.attr = attr;<span class=\"comment\">//元素的被绑定的属性值，比如如果是文本节点就可以是nodeValue</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.el[<span class=\"keyword\">this</span>.attr] = <span class=\"keyword\">this</span>.elementValue = elementValue;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们的set可以这样写:</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> set(<span class=\"keyword\">target</span>, key, <span class=\"keyword\">value</span>, receiver) &#123;</span><br><span class=\"line\">    const result = Reflect.set(<span class=\"keyword\">target</span>, key, <span class=\"keyword\">value</span>, receiver);</span><br><span class=\"line\">    var dataSet = receiver || <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    dataSet.__bindings[key].forEach(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(item)</span></span>&#123;</span><br><span class=\"line\">        item.el[item.attr] = item.elementValue = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来可能还有一个问题：我们的<code></code>实际上只是节点的一部分，这并不是节点啊，另外我们是不是还可以这么写：<code>&lt;div&gt;name: age:&lt;/div&gt;</code>？</p>\n<p>关于这两个问题，前者的答案是我们将<code></code>替换成一个文本节点，而为了应对后者的情况，我们需要将两个被绑定数据中间和前后的内容，都变成新的文本节点，然后这些文本节点组成文本节点串。(这里多说一句，html5的normalize方法可以将多个文本节点合并成一个，如果不小心调用了它，那我们的程序就要GG了)</p>\n<p>所以我们在<code>_compile</code>函数首先：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"built_in\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> nodes = root.children;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> bindDataTester = <span class=\"keyword\">new</span> <span class=\"type\">RegExp</span>(<span class=\"string\">\"&#123;&#123;(.*?)&#125;&#125;\"</span>,<span class=\"string\">\"ig\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(let i=<span class=\"number\">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> node=nodes[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还有html字节点，则递归</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children.length)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>._compile(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> matches = node.innerHTML.match(bindDataTester);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matches)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"keyword\">new</span><span class=\"type\">Matches</span> = matches.map(<span class=\"function\"><span class=\"keyword\">function</span> </span>(item) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>  item.replace(/&#123;&#123;(.*?)&#125;&#125;/,<span class=\"string\">\"$1\"</span>)</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> splitTextNodes  = node.innerHTML.split(/&#123;&#123;.*?&#125;&#125;/);</span><br><span class=\"line\">                node.innerHTML=<span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">//更新DOM，处理同一个textnode里面多次绑定情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(splitTextNodes[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                    node.append(document.createTextNode(splitTextNodes[<span class=\"number\">0</span>]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(let ii=<span class=\"number\">0</span>;ii&lt;<span class=\"keyword\">new</span><span class=\"type\">Matches</span>.length;ii++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> el = document.createTextNode(<span class=\"string\">''</span>);</span><br><span class=\"line\">                    node.appendChild(el);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(splitTextNodes[ii+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                        node.append(document.createTextNode(splitTextNodes[ii+<span class=\"number\">1</span>]));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                <span class=\"comment\">//对数据和dom进行绑定</span></span><br><span class=\"line\">                let returnCode = !<span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]?</span><br><span class=\"line\">                    <span class=\"built_in\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]] = [<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">\"nodeValue\"</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]])]</span><br><span class=\"line\">                    :<span class=\"type\">this</span>._data.__bindings[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]].push(<span class=\"keyword\">new</span> <span class=\"type\">Directive</span>(el,<span class=\"built_in\">this</span>,<span class=\"string\">\"nodeValue\"</span>,<span class=\"built_in\">this</span>.data[<span class=\"keyword\">new</span><span class=\"type\">Matches</span>[ii]]))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们的数据绑定阶段就写好了，接下来，我们处理<code>&lt;input p-model = &quot;name&quot; /&gt;</code>这样的情况。</p>\n<p>这实际上是一个指令，我们只需要当识别到这一个指令的时候，做一些处理，即可：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(<span class=\"keyword\">node</span>.<span class=\"title\">hasAttribute</span>((<span class=\"string\">\"p-model\"</span>))</span><br><span class=\"line\">                &amp;&amp; <span class=\"keyword\">node</span>.<span class=\"title\">tagName</span>.toLocaleUpperCase()==<span class=\"string\">\"INPUT\"</span> || <span class=\"keyword\">node</span>.<span class=\"title\">tagName</span>.toLocaleUpperCase()==<span class=\"string\">\"TEXTAREA\"</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">node</span>.<span class=\"title\">addEventListener</span>(<span class=\"string\">\"input\"</span>, (function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    var attributeValue = <span class=\"keyword\">node</span>.<span class=\"title\">getAttribute</span>(<span class=\"string\">\"p-model\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                    if(_this._data.__bindings[attributeValue]) _this._data.__bindings[attributeValue].push(new Directive(<span class=\"keyword\">node</span><span class=\"title\">,_this</span>,<span class=\"string\">\"value\"</span>,_this.data[attributeValue])) ;</span><br><span class=\"line\">                    else _this._data.__bindings[attributeValue] = [new Directive(<span class=\"keyword\">node</span><span class=\"title\">,_this</span>,<span class=\"string\">\"value\"</span>,_this.data[attributeValue])];</span><br><span class=\"line\"></span><br><span class=\"line\">                    return function (event) &#123;</span><br><span class=\"line\">                        _this.data[attributeValue]=event.target.value</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，上面调用了一个<code>IIFE</code>，实际绑定的函数只有返回的函数那一小部分。</p>\n<p>最后我们处理事件的情况：<code>&lt;button p-click=&quot;test(2)&quot;&gt;button1&lt;/button&gt;</code></p>\n<p>实际上这比处理<code>p-model</code>还简单，但是我们为了支持函数参数的情况，处理了一下传入参数，另外我实际上将<code>event</code>始终作为一个参数传递，这也许并不是好的实践，因为使用的时候还要多注意。</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(node.hasAttribute(<span class=\"string\">\"p-click\"</span>)) &#123;</span><br><span class=\"line\">                node.addEventListener(<span class=\"string\">\"click\"</span>,function()&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> attributeValue=node.getAttribute(<span class=\"string\">\"p-click\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> <span class=\"keyword\">args</span>=/\\(.*\\)/.exec(attributeValue);</span><br><span class=\"line\">                    <span class=\"comment\">//允许参数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">args</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>[0];</span><br><span class=\"line\">                        attributeValue=attributeValue.<span class=\"keyword\">replace</span>(<span class=\"keyword\">args</span>,<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">args</span>=<span class=\"keyword\">args</span>.<span class=\"keyword\">replace</span>(/[\\(\\)\\'\\<span class=\"string\">\"]/g,'').split(\"</span>,\");</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">args</span>=[];</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> function (event) &#123;</span><br><span class=\"line\">                        _this.methods[attributeValue].apply(_this,[event,...<span class=\"keyword\">args</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经将所有的代码分析完了，是不是很清爽？代码除去注释约100行，所有源代码可以在<a href=\"https://github.com/aircloud/Polar.js\" target=\"_blank\" rel=\"noopener\">这里下载</a>。这当然不能算作一个框架了，不过可以学习学习，这学期有时间的话，还要继续完善，也欢迎大家一起探讨。</p>\n<p>一起学习，一起提高，做技术应当是直接的，有问题欢迎指出～</p>\n<hr>\n<p>最后说的第三点：是自己还是一个学生，做这些内容也仅仅是出于兴趣，因为找暑期实习比较艰难，在等待鹅厂面试间隙写的这个程序，压压惊(然而并没有消息)。</p>\n"},{"title":"深入Vue源代码解决时序问题一","date":"2019-07-06T07:21:51.000Z","_content":"\n>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。\n\n最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：\n\n```\nTypeError: undefined is not an object(evaluating 'e.isDestroyed\"\n```\n\n接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：\n\n```\nTypeError: undefined is not an object(evaluating 'componentInstance.isDestroyed\"\n```\n\n我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：\n\n```javascript\ndestroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) { // 这里报错\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n```\n\n这里是 `componentInstance` 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。\n\n于是我们查看业务代码的所有日志，又发现了这样一条报错：\n\n```\n[Vue warn]: Error in nextTick: \"TypeError: undefined is not an object (evaluating 'vm.$options')\" \n```\n\n初始化阶段出现这样一个错误，我们怀疑 `vm` 就是上文的 `componentInstance`，于是，我们打印报错堆栈：\n\n```javascript\n 调用栈:\nfunction updateChildComponent(\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n        //...\n        var hasChildren = !!(\n              renderChildren ||\n              vm.$options._renderChildren || // 这里报错\n              parentVnode.data.scopedSlots ||\n              vm.$scopedSlots !== emptyObject\n            );\n    }\n\nfunction prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData,\n        options.listeners,\n        vnode,\n        options.children\n      );\n    }\n\nfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {}\nfunction patch(oldVnode, vnode, hydrating, removeOnly) {}\nfunction (vnode, hydrating) {}\nfunction () {\n        vm._update(vm._render(), hydrating);\n      }\nfunction get() {}\nfunction getAndInvoke(cb) {}\nfunction run() {}\nfunction flushSchedulerQueue() {}\nfunction flushCallbacks() {}\n```\n\n调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：\n\n* 初始化阶段为 `undefined` 的 `vm`，就是 `componentInstance`，也就是和 destroy 阶段的报错属于同一个原因。\n* 根据调用栈发现，这是一个更新阶段的报错。\n\n这引发了我们的思考：更新阶段找不到 `componentInstance` 报错。\n\n这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：\n\n```\ncreated() {\n    this.getFeedsListFromCache();\n},\nmethods: {\n    getFeedsListFromCache() {\n        viola.requireAPI(\"cache\").getItem(this.cacheKey_feeds, data => {\n            this.processData(data.list);\n        });\n    },\n    processData(list = [], opt = {}) {\n        if (this.list.length < cacehFeedsLength) {\n        }\n        this.list = [];\n    },\n}\n```\n\n我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：\n\n* 在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。\n\n首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：\n\n* created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。\n* 该函数队列会通过默认为 `Promise.then` 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。\n\n从代码层面上来讲，这几个流程应该是这样的：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程\n ├── callHook(vm, 'beforeMount');\n ├──  callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n └── flushCallbacks // 执行 更新\n```\n\n然后我们分析我们这里的流程，首先值得强调的是这个函数 `viola.requireAPI(\"cache\").getItem`，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，**这是一个同步函数**，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）\n\n接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── flushCallbacks // 执行 更新\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程 \n ├── callHook(vm, 'beforeMount');\n └── callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n```\n\n我们发现，我们的执行流程出现了很大问题：**在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题**。\n\n我们可看下调用 `flushCallbacks` 的代码：\n\n```javascript\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} \n```\n\n这里 `microTimerFunc` 的 `p.then`，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数**理应**在该事件循环中，优先于微任务执行）。\n\n我们找到了根源，接下来就是分析解决方案和根本原因。\n\n由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：\n\n* 将 vue 的微任务模式（默认）改成宏任务模式：`var useMacroTask = false; => true`。\n* 在 created 阶段的加一个 `setTimeout(0)`。\n\n不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：\n\n* `viola.requireAPI(\"cache\").getItem` 这个函数到底做了什么？其对事件循环有什么影响？\n* 在执行 `microTimerFunc` 的时候，为什么 `p.then` 优先于 `vm.$mount` 执行了？\n* 该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？\n\n对于这些疑问，Vue 源代码中也做了一些评论：\n\n```\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\n```\n\n不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。\n\n\n\n","source":"_posts/深入Vue源代码解决时序问题一.md","raw":"---\ntitle: 深入Vue源代码解决时序问题一\ndate: 2019-07-06 15:21:51\ntags:\n\t- Vue\n\t- viola\n---\n\n>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。\n\n最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：\n\n```\nTypeError: undefined is not an object(evaluating 'e.isDestroyed\"\n```\n\n接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：\n\n```\nTypeError: undefined is not an object(evaluating 'componentInstance.isDestroyed\"\n```\n\n我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：\n\n```javascript\ndestroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) { // 这里报错\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n```\n\n这里是 `componentInstance` 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。\n\n于是我们查看业务代码的所有日志，又发现了这样一条报错：\n\n```\n[Vue warn]: Error in nextTick: \"TypeError: undefined is not an object (evaluating 'vm.$options')\" \n```\n\n初始化阶段出现这样一个错误，我们怀疑 `vm` 就是上文的 `componentInstance`，于是，我们打印报错堆栈：\n\n```javascript\n 调用栈:\nfunction updateChildComponent(\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n        //...\n        var hasChildren = !!(\n              renderChildren ||\n              vm.$options._renderChildren || // 这里报错\n              parentVnode.data.scopedSlots ||\n              vm.$scopedSlots !== emptyObject\n            );\n    }\n\nfunction prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData,\n        options.listeners,\n        vnode,\n        options.children\n      );\n    }\n\nfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {}\nfunction patch(oldVnode, vnode, hydrating, removeOnly) {}\nfunction (vnode, hydrating) {}\nfunction () {\n        vm._update(vm._render(), hydrating);\n      }\nfunction get() {}\nfunction getAndInvoke(cb) {}\nfunction run() {}\nfunction flushSchedulerQueue() {}\nfunction flushCallbacks() {}\n```\n\n调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：\n\n* 初始化阶段为 `undefined` 的 `vm`，就是 `componentInstance`，也就是和 destroy 阶段的报错属于同一个原因。\n* 根据调用栈发现，这是一个更新阶段的报错。\n\n这引发了我们的思考：更新阶段找不到 `componentInstance` 报错。\n\n这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：\n\n```\ncreated() {\n    this.getFeedsListFromCache();\n},\nmethods: {\n    getFeedsListFromCache() {\n        viola.requireAPI(\"cache\").getItem(this.cacheKey_feeds, data => {\n            this.processData(data.list);\n        });\n    },\n    processData(list = [], opt = {}) {\n        if (this.list.length < cacehFeedsLength) {\n        }\n        this.list = [];\n    },\n}\n```\n\n我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：\n\n* 在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。\n\n首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：\n\n* created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。\n* 该函数队列会通过默认为 `Promise.then` 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。\n\n从代码层面上来讲，这几个流程应该是这样的：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程\n ├── callHook(vm, 'beforeMount');\n ├──  callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n └── flushCallbacks // 执行 更新\n```\n\n然后我们分析我们这里的流程，首先值得强调的是这个函数 `viola.requireAPI(\"cache\").getItem`，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，**这是一个同步函数**，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）\n\n接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：\n\n```\n ├── callHook(vm, 'created'); // 执行created 钩子\n ├── proxySetter(val); // 改变数据，调用 proxy\n ├── Watcher.prototype.update; // 调用 Watcher，将 update 操作入栈\n ├── flushCallbacks // 执行 更新\n ├── vm.$mount(vm.$options.el); // 执行 mount 流程 \n ├── callHook(vm, 'beforeMount');\n └── callHook(vm, 'mounted'); // 依次调用 beforeMount 和 mounted\n```\n\n我们发现，我们的执行流程出现了很大问题：**在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题**。\n\n我们可看下调用 `flushCallbacks` 的代码：\n\n```javascript\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} \n```\n\n这里 `microTimerFunc` 的 `p.then`，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数**理应**在该事件循环中，优先于微任务执行）。\n\n我们找到了根源，接下来就是分析解决方案和根本原因。\n\n由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：\n\n* 将 vue 的微任务模式（默认）改成宏任务模式：`var useMacroTask = false; => true`。\n* 在 created 阶段的加一个 `setTimeout(0)`。\n\n不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：\n\n* `viola.requireAPI(\"cache\").getItem` 这个函数到底做了什么？其对事件循环有什么影响？\n* 在执行 `microTimerFunc` 的时候，为什么 `p.then` 优先于 `vm.$mount` 执行了？\n* 该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？\n\n对于这些疑问，Vue 源代码中也做了一些评论：\n\n```\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\n```\n\n不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。\n\n\n\n","slug":"深入Vue源代码解决时序问题一","published":1,"updated":"2020-02-17T12:50:55.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o6000b8zom32ypes1v","content":"<blockquote>\n<p>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。</p>\n</blockquote>\n<p>最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: undefined <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> an <span class=\"built_in\">object</span>(evaluating <span class=\"comment\">'e.isDestroyed\"</span></span><br></pre></td></tr></table></figure>\n<p>接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: undefined <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> an <span class=\"built_in\">object</span>(evaluating <span class=\"comment\">'componentInstance.isDestroyed\"</span></span><br></pre></td></tr></table></figure>\n<p>我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">destroy</span> (<span class=\"params\">vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> componentInstance = vnode.componentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!componentInstance._isDestroyed) &#123; <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class=\"line\">        componentInstance.$destroy();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deactivateChildComponent(componentInstance, <span class=\"literal\">true</span> <span class=\"comment\">/* direct */</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是 <code>componentInstance</code> 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。</p>\n<p>于是我们查看业务代码的所有日志，又发现了这样一条报错：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Vue warn]: <span class=\"builtin-name\">Error</span> <span class=\"keyword\">in</span> nextTick: <span class=\"string\">\"TypeError: undefined is not an object (evaluating 'vm.<span class=\"variable\">$options</span>')\"</span></span><br></pre></td></tr></table></figure>\n<p>初始化阶段出现这样一个错误，我们怀疑 <code>vm</code> 就是上文的 <code>componentInstance</code>，于是，我们打印报错堆栈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 调用栈:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    vm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    propsData,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    listeners,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    parentVnode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    renderChildren</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> hasChildren = !!(</span><br><span class=\"line\">              renderChildren ||</span><br><span class=\"line\">              vm.$options._renderChildren || <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">              parentVnode.data.scopedSlots ||</span><br><span class=\"line\">              vm.$scopedSlots !== emptyObject</span><br><span class=\"line\">            );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepatch</span>(<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = vnode.componentOptions;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class=\"line\">      updateChildComponent(</span><br><span class=\"line\">        child,</span><br><span class=\"line\">        options.propsData,</span><br><span class=\"line\">        options.listeners,</span><br><span class=\"line\">        vnode,</span><br><span class=\"line\">        options.children</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span>(<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span>(<span class=\"params\">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode, hydrating</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vm._update(vm._render(), hydrating);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAndInvoke</span>(<span class=\"params\">cb</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushSchedulerQueue</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushCallbacks</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：</p>\n<ul>\n<li>初始化阶段为 <code>undefined</code> 的 <code>vm</code>，就是 <code>componentInstance</code>，也就是和 destroy 阶段的报错属于同一个原因。</li>\n<li>根据调用栈发现，这是一个更新阶段的报错。</li>\n</ul>\n<p>这引发了我们的思考：更新阶段找不到 <code>componentInstance</code> 报错。</p>\n<p>这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getFeedsListFromCache();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    getFeedsListFromCache() &#123;</span><br><span class=\"line\">        viola.requireAPI(<span class=\"string\">\"cache\"</span>).getItem(<span class=\"keyword\">this</span>.cacheKey_feeds, <span class=\"keyword\">data</span> =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.processData(<span class=\"keyword\">data</span>.list);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    processData(list = [], opt = &#123;&#125;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.list.length &lt; cacehFeedsLength) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：</p>\n<ul>\n<li>在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。</li>\n</ul>\n<p>首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：</p>\n<ul>\n<li>created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。</li>\n<li>该函数队列会通过默认为 <code>Promise.then</code> 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。</li>\n</ul>\n<p>从代码层面上来讲，这几个流程应该是这样的：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── callHook(vm, <span class=\"string\">'created'</span>); <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxySetter(val); <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── Watcher.prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── vm.<span class=\"symbol\">$</span>mount(vm.<span class=\"symbol\">$</span><span class=\"keyword\">options</span>.el); <span class=\"comment\">// 执行 mount 流程</span></span><br><span class=\"line\">├── callHook(vm, <span class=\"string\">'beforeMount'</span>);</span><br><span class=\"line\">├──  callHook(vm, <span class=\"string\">'mounted'</span>); <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br><span class=\"line\">└── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br></pre></td></tr></table></figure>\n<p>然后我们分析我们这里的流程，首先值得强调的是这个函数 <code>viola.requireAPI(&quot;cache&quot;).getItem</code>，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，<strong>这是一个同步函数</strong>，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）</p>\n<p>接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── callHook(vm, <span class=\"string\">'created'</span>); <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxySetter(val); <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── Watcher.prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br><span class=\"line\">├── vm.<span class=\"symbol\">$</span>mount(vm.<span class=\"symbol\">$</span><span class=\"keyword\">options</span>.el); <span class=\"comment\">// 执行 mount 流程 </span></span><br><span class=\"line\">├── callHook(vm, <span class=\"string\">'beforeMount'</span>);</span><br><span class=\"line\">└── callHook(vm, <span class=\"string\">'mounted'</span>); <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br></pre></td></tr></table></figure>\n<p>我们发现，我们的执行流程出现了很大问题：<strong>在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题</strong>。</p>\n<p>我们可看下调用 <code>flushCallbacks</code> 的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; isNative(<span class=\"built_in\">Promise</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  microTimerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    p.then(flushCallbacks);</span><br><span class=\"line\">    <span class=\"comment\">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class=\"line\">    <span class=\"comment\">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class=\"line\">    <span class=\"comment\">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class=\"line\">    <span class=\"comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class=\"line\">    <span class=\"comment\">// \"force\" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isIOS) &#123; setTimeout(noop); &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 <code>microTimerFunc</code> 的 <code>p.then</code>，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数<strong>理应</strong>在该事件循环中，优先于微任务执行）。</p>\n<p>我们找到了根源，接下来就是分析解决方案和根本原因。</p>\n<p>由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：</p>\n<ul>\n<li>将 vue 的微任务模式（默认）改成宏任务模式：<code>var useMacroTask = false; =&gt; true</code>。</li>\n<li>在 created 阶段的加一个 <code>setTimeout(0)</code>。</li>\n</ul>\n<p>不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：</p>\n<ul>\n<li><code>viola.requireAPI(&quot;cache&quot;).getItem</code> 这个函数到底做了什么？其对事件循环有什么影响？</li>\n<li>在执行 <code>microTimerFunc</code> 的时候，为什么 <code>p.then</code> 优先于 <code>vm.$mount</code> 执行了？</li>\n<li>该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？</li>\n</ul>\n<p>对于这些疑问，Vue 源代码中也做了一些评论：</p>\n<figure class=\"highlight vhdl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Here we have async deferring wrappers using both microtasks <span class=\"keyword\">and</span> (macro) tasks.</span><br><span class=\"line\">// <span class=\"keyword\">In</span> &lt; <span class=\"number\">2.4</span> we used microtasks everywhere, but there are some scenarios where</span><br><span class=\"line\">// microtasks have too high a priority <span class=\"keyword\">and</span> fire <span class=\"keyword\">in</span> between supposedly</span><br><span class=\"line\">// sequential events (e.g. #<span class=\"number\">4521</span>, #<span class=\"number\">6690</span>) <span class=\"keyword\">or</span> even between bubbling <span class=\"keyword\">of</span> the same</span><br><span class=\"line\">// event (#<span class=\"number\">6566</span>). However, using (macro) tasks everywhere also has subtle problems</span><br><span class=\"line\">// <span class=\"keyword\">when</span> state <span class=\"keyword\">is</span> changed right before repaint (e.g. #<span class=\"number\">6813</span>, <span class=\"keyword\">out</span>-<span class=\"keyword\">in</span> transitions).</span><br><span class=\"line\">// Here we <span class=\"keyword\">use</span> microtask by <span class=\"keyword\">default</span>, but expose a way <span class=\"keyword\">to</span> <span class=\"keyword\">force</span> (macro) task <span class=\"keyword\">when</span></span><br><span class=\"line\">// needed (e.g. <span class=\"keyword\">in</span> event handlers attached by v-<span class=\"keyword\">on</span>).</span><br></pre></td></tr></table></figure>\n<p>不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。</p>\n</blockquote>\n<p>最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: undefined <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> an <span class=\"built_in\">object</span>(evaluating <span class=\"comment\">'e.isDestroyed\"</span></span><br></pre></td></tr></table></figure>\n<p>接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TypeError: undefined <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> an <span class=\"built_in\">object</span>(evaluating <span class=\"comment\">'componentInstance.isDestroyed\"</span></span><br></pre></td></tr></table></figure>\n<p>我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">destroy</span> (<span class=\"params\">vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> componentInstance = vnode.componentInstance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!componentInstance._isDestroyed) &#123; <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class=\"line\">        componentInstance.$destroy();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        deactivateChildComponent(componentInstance, <span class=\"literal\">true</span> <span class=\"comment\">/* direct */</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这里是 <code>componentInstance</code> 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。</p>\n<p>于是我们查看业务代码的所有日志，又发现了这样一条报错：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Vue warn]: <span class=\"builtin-name\">Error</span> <span class=\"keyword\">in</span> nextTick: <span class=\"string\">\"TypeError: undefined is not an object (evaluating 'vm.<span class=\"variable\">$options</span>')\"</span></span><br></pre></td></tr></table></figure>\n<p>初始化阶段出现这样一个错误，我们怀疑 <code>vm</code> 就是上文的 <code>componentInstance</code>，于是，我们打印报错堆栈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 调用栈:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildComponent</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    vm,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    propsData,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    listeners,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    parentVnode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    renderChildren</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> hasChildren = !!(</span><br><span class=\"line\">              renderChildren ||</span><br><span class=\"line\">              vm.$options._renderChildren || <span class=\"comment\">// 这里报错</span></span><br><span class=\"line\">              parentVnode.data.scopedSlots ||</span><br><span class=\"line\">              vm.$scopedSlots !== emptyObject</span><br><span class=\"line\">            );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepatch</span>(<span class=\"params\">oldVnode, vnode</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> options = vnode.componentOptions;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class=\"line\">      updateChildComponent(</span><br><span class=\"line\">        child,</span><br><span class=\"line\">        options.propsData,</span><br><span class=\"line\">        options.listeners,</span><br><span class=\"line\">        vnode,</span><br><span class=\"line\">        options.children</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span>(<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span>(<span class=\"params\">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">vnode, hydrating</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        vm._update(vm._render(), hydrating);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAndInvoke</span>(<span class=\"params\">cb</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushSchedulerQueue</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flushCallbacks</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：</p>\n<ul>\n<li>初始化阶段为 <code>undefined</code> 的 <code>vm</code>，就是 <code>componentInstance</code>，也就是和 destroy 阶段的报错属于同一个原因。</li>\n<li>根据调用栈发现，这是一个更新阶段的报错。</li>\n</ul>\n<p>这引发了我们的思考：更新阶段找不到 <code>componentInstance</code> 报错。</p>\n<p>这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getFeedsListFromCache();</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">    getFeedsListFromCache() &#123;</span><br><span class=\"line\">        viola.requireAPI(<span class=\"string\">\"cache\"</span>).getItem(<span class=\"keyword\">this</span>.cacheKey_feeds, <span class=\"keyword\">data</span> =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.processData(<span class=\"keyword\">data</span>.list);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    processData(list = [], opt = &#123;&#125;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.list.length &lt; cacehFeedsLength) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.list = [];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：</p>\n<ul>\n<li>在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。</li>\n</ul>\n<p>首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：</p>\n<ul>\n<li>created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。</li>\n<li>该函数队列会通过默认为 <code>Promise.then</code> 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。</li>\n</ul>\n<p>从代码层面上来讲，这几个流程应该是这样的：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── callHook(vm, <span class=\"string\">'created'</span>); <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxySetter(val); <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── Watcher.prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── vm.<span class=\"symbol\">$</span>mount(vm.<span class=\"symbol\">$</span><span class=\"keyword\">options</span>.el); <span class=\"comment\">// 执行 mount 流程</span></span><br><span class=\"line\">├── callHook(vm, <span class=\"string\">'beforeMount'</span>);</span><br><span class=\"line\">├──  callHook(vm, <span class=\"string\">'mounted'</span>); <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br><span class=\"line\">└── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br></pre></td></tr></table></figure>\n<p>然后我们分析我们这里的流程，首先值得强调的是这个函数 <code>viola.requireAPI(&quot;cache&quot;).getItem</code>，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，<strong>这是一个同步函数</strong>，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）</p>\n<p>接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── callHook(vm, <span class=\"string\">'created'</span>); <span class=\"comment\">// 执行created 钩子</span></span><br><span class=\"line\">├── proxySetter(val); <span class=\"comment\">// 改变数据，调用 proxy</span></span><br><span class=\"line\">├── Watcher.prototype.update; <span class=\"comment\">// 调用 Watcher，将 update 操作入栈</span></span><br><span class=\"line\">├── flushCallbacks <span class=\"comment\">// 执行 更新</span></span><br><span class=\"line\">├── vm.<span class=\"symbol\">$</span>mount(vm.<span class=\"symbol\">$</span><span class=\"keyword\">options</span>.el); <span class=\"comment\">// 执行 mount 流程 </span></span><br><span class=\"line\">├── callHook(vm, <span class=\"string\">'beforeMount'</span>);</span><br><span class=\"line\">└── callHook(vm, <span class=\"string\">'mounted'</span>); <span class=\"comment\">// 依次调用 beforeMount 和 mounted</span></span><br></pre></td></tr></table></figure>\n<p>我们发现，我们的执行流程出现了很大问题：<strong>在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题</strong>。</p>\n<p>我们可看下调用 <code>flushCallbacks</code> 的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Promise</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; isNative(<span class=\"built_in\">Promise</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">  microTimerFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    p.then(flushCallbacks);</span><br><span class=\"line\">    <span class=\"comment\">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class=\"line\">    <span class=\"comment\">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class=\"line\">    <span class=\"comment\">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class=\"line\">    <span class=\"comment\">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class=\"line\">    <span class=\"comment\">// \"force\" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isIOS) &#123; setTimeout(noop); &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里 <code>microTimerFunc</code> 的 <code>p.then</code>，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数<strong>理应</strong>在该事件循环中，优先于微任务执行）。</p>\n<p>我们找到了根源，接下来就是分析解决方案和根本原因。</p>\n<p>由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：</p>\n<ul>\n<li>将 vue 的微任务模式（默认）改成宏任务模式：<code>var useMacroTask = false; =&gt; true</code>。</li>\n<li>在 created 阶段的加一个 <code>setTimeout(0)</code>。</li>\n</ul>\n<p>不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：</p>\n<ul>\n<li><code>viola.requireAPI(&quot;cache&quot;).getItem</code> 这个函数到底做了什么？其对事件循环有什么影响？</li>\n<li>在执行 <code>microTimerFunc</code> 的时候，为什么 <code>p.then</code> 优先于 <code>vm.$mount</code> 执行了？</li>\n<li>该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？</li>\n</ul>\n<p>对于这些疑问，Vue 源代码中也做了一些评论：</p>\n<figure class=\"highlight vhdl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Here we have async deferring wrappers using both microtasks <span class=\"keyword\">and</span> (macro) tasks.</span><br><span class=\"line\">// <span class=\"keyword\">In</span> &lt; <span class=\"number\">2.4</span> we used microtasks everywhere, but there are some scenarios where</span><br><span class=\"line\">// microtasks have too high a priority <span class=\"keyword\">and</span> fire <span class=\"keyword\">in</span> between supposedly</span><br><span class=\"line\">// sequential events (e.g. #<span class=\"number\">4521</span>, #<span class=\"number\">6690</span>) <span class=\"keyword\">or</span> even between bubbling <span class=\"keyword\">of</span> the same</span><br><span class=\"line\">// event (#<span class=\"number\">6566</span>). However, using (macro) tasks everywhere also has subtle problems</span><br><span class=\"line\">// <span class=\"keyword\">when</span> state <span class=\"keyword\">is</span> changed right before repaint (e.g. #<span class=\"number\">6813</span>, <span class=\"keyword\">out</span>-<span class=\"keyword\">in</span> transitions).</span><br><span class=\"line\">// Here we <span class=\"keyword\">use</span> microtask by <span class=\"keyword\">default</span>, but expose a way <span class=\"keyword\">to</span> <span class=\"keyword\">force</span> (macro) task <span class=\"keyword\">when</span></span><br><span class=\"line\">// needed (e.g. <span class=\"keyword\">in</span> event handlers attached by v-<span class=\"keyword\">on</span>).</span><br></pre></td></tr></table></figure>\n<p>不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。</p>\n"},{"title":"深入浏览器web渲染与优化-续","date":"2017-08-31T11:04:03.000Z","_content":">本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","source":"_posts/深入浏览器web渲染与优化-续.md","raw":"---\ntitle: 深入浏览器web渲染与优化-续\ndate: 2017-08-31 19:04:03\ntags:\n    - 性能优化\n---\n>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析\n\n上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。\n\n首先，一个网页的加载，需要什么工作呢？\n\n![](https://www.10000h.top/images/data_img/webRender2/P1.png)\n\n这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。\n\n数据到端之后，又经过以下过程，才最终显示出来：\n\n![](https://www.10000h.top/images/data_img/webRender2/P2.png)\n\n在这个过程中，我们怎么衡量性能呢？\n\n固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：\n\n![](https://www.10000h.top/images/data_img/webRender2/P3.png)\n\n但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。\n\n所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。\n\n目前这个标准是**首屏时间**(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，*另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要--from dorsywang*)\n\n那么**首屏时间**怎么测量呢？\n\n**拿摄像机快速拍照测量的**。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。  \n因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。\n当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。\n\n知道了怎么测算，那么接下来分析影响这个指标的一些原因：\n\n* 资源阻塞内核线程\n\n我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。\n\n对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。\n\n当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)\n\n* 中文Layout的时间过长\n\n这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。\n\n为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。\n\n* 首次渲染太慢\n\n为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制\n\n* 一次解析内容过多\n\n采用首屏探测机制，优先解析首屏内容。\n\n另外，这里可以前端配合去做首屏优化：\n\n\n在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏\n\n```\n<meta name=‘x5-pagetype’ content=‘optpage'>\n```\n然后在首屏分界的地方：\n\n```\n<first-screen/>\n```\n\n有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。\n\n另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。  \n*TIP:主资源中关联的子资源预拉取不用主动调用*\n\n* 预先操作\n\n另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：\n\n* 在\"黏贴并转到\"之前就开始进行网络请求和预渲染\n* 经常访问的站点可以预解析DNS\n* 点击地址栏时进行搜索预连接\n* 点击链接时，先预链接，再做跳转。\n* ......\n\n### 其他方式优化\n\n实际上上文主要讲了客户端方面的优化工作，实际上对于\"云\"、\"管\"两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考\n\n##### 后台提速\n\n* 直接使用IP，节省dns的查询时间\n* 维持长连接\n* HTTP1.1启用包头节省\n* 服务器缓存\n* 文本资源压缩传输GZIP(6)\n* 图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。\n\n##### 降低网络时延\n\n* 就快接入和就近接入\n\n在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。\n\n相比较而言，选择就快接入，是一个能够提效的方式。\n\n##### 内容防劫持\n\n运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。\n\n#### QUIC和http2\n\nQUIC 基于UDP的协议通讯方式，有这些优势：\n\n* 延迟少\n* 前向纠错\n* 没有**线头阻塞[注1]**的多路复用\n* 通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能\n\n——————\n\n注1：线头阻塞：\n\n![](https://www.10000h.top/images/data_img/webRender2/P4.png)\n\n——————\n\n附1: 带宽和延迟对网页加载的影响：\n\n![](https://www.10000h.top/images/data_img/webRender2/X1.png)\n","slug":"深入浏览器web渲染与优化-续","published":1,"updated":"2020-02-17T12:50:55.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o7000c8zommmmg8iv2","content":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\" alt=\"\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\" alt=\"\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\" alt=\"\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage'&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有<strong>线头阻塞[注1]</strong>的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\" alt=\"\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇文章接上一篇继续分析浏览器web渲染相关内容，但是更侧重优化工作。当然，主要还是基于X5来分析</p>\n</blockquote>\n<p>上一篇文章我们主要是从浏览器内核的线程角度来分析相关工作的，对整体流程没有宏观清晰的分析，这次我们从宏观到微观，从整体到局部，来进行分析和探究可以优化的地方。</p>\n<p>首先，一个网页的加载，需要什么工作呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P1.png\" alt=\"\"></p>\n<p>这个工作可以分为三部分：云(云端)、管(传输链路)、端(客户端)，从云经过管传到端，然后经过加载解析排版渲染，从而完成网页从请求到呈现的工作(当然，我们这里没有涉及协议的分析，实际上根据协议不同，这个传输可能是多次传输)。</p>\n<p>数据到端之后，又经过以下过程，才最终显示出来：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P2.png\" alt=\"\"></p>\n<p>在这个过程中，我们怎么衡量性能呢？</p>\n<p>固然，我们有诸多浏览器提供的API，这些API能让我们获取到较多信息并且记录上报：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P3.png\" alt=\"\"></p>\n<p>但是这些具体数值表达的含义有限，并且他们实际上也不等于用户体验。</p>\n<p>所以，找到一个科学并且可以检测的标准，并且这个标准可以和用户体验有正相关关系，这个是至关重要的。</p>\n<p>目前这个标准是<strong>首屏时间</strong>(就之前自己的了解，具体的还区分首屏展示时间和首屏可交互时间，但是这里讲师不做区分，就下文提供的测算方法而言，显然这里指的是首屏展示时间，<em>另外，展示后到用户的第一次操作都会有一个至少1s的延时，毕竟用户手指按下的动作是会比较慢的，这个时间js的交互都能完成了，所以首屏展示时间更加重要–from dorsywang</em>)</p>\n<p>那么<strong>首屏时间</strong>怎么测量呢？</p>\n<p><strong>拿摄像机快速拍照测量的</strong>。这个答案可能有些吃惊，但是目前X5内核业务的相关开发人员的确就是采用这种方式测算的，通过高速相机不断拍照，然后辅助图像识别，判断首屏是否已经加载完成，最终再通过人工回归校对。<br>因为如果采用程序检测的话，基本上都会对过程本身造成一定的影响，所以没有采用这种方式。<br>当然，通过摄像+图像识别的这种方式也是有一定的弊端，比如说，假设首屏有一个图片，而图片的加载通常比较慢并且不影响css、js的加载，这个时候直接通过图片识别的话就可能会有一定的误判。</p>\n<p>知道了怎么测算，那么接下来分析影响这个指标的一些原因：</p>\n<ul>\n<li>资源阻塞内核线程</li>\n</ul>\n<p>我们知道，一般情况下，css和JS是阻塞页面的，当然也会对首屏时间造成影响。</p>\n<p>对这个问题，X5内核有关键子资源(阻塞资源)缓存，这里的关键资源，指的是内核经过统计判断得出的业务常用的关键子资源。</p>\n<p>当然，这个统计也可能缺乏一定的准确性，所以相关团队也正在推进这方面的内容规范化(比如写入Web App Manifest)</p>\n<ul>\n<li>中文Layout的时间过长</li>\n</ul>\n<p>这个问题我之前没有听说过，但是的确是这样子，实际上，浏览器在绘制文字的时候经历的过程非常的多，其中有一个环节是找到文字的宽度和高度(因为在英文状态下，每一个字符的宽度是不同的，所以每一个字符都要查找，但是英文总共只有26个字符)，而中文由于字符比较多，常用得就有6000多个，完整的更是有2万个以上，所以这个过程需要花费更多的时间。</p>\n<p>为了解决这个问题，X5内核考虑到中文文字几乎都是等宽等高的，所以这个过程对一个文字串来说只需要查询一次即可，实际上是节约了这个环节。</p>\n<ul>\n<li>首次渲染太慢</li>\n</ul>\n<p>为了解决这个问题，可以采用先绘制首屏的方式，这个也就是基于第一篇文章中讲到的浏览器的分块渲染机制</p>\n<ul>\n<li>一次解析内容过多</li>\n</ul>\n<p>采用首屏探测机制，优先解析首屏内容。</p>\n<p>另外，这里可以前端配合去做首屏优化：</p>\n<p>在首屏的位置插入首屏标签，内核解析到标签后立即终止解析并且排版上屏</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta <span class=\"attribute\">name</span>=‘x5-pagetype’ <span class=\"attribute\">content</span>=‘optpage'&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在首屏分界的地方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;first-screen/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这，可以专门去优化首屏标签之前的内容(这个标签前尽量展现耗时少和不需要阻塞解析的资源)。</p>\n<p>另外，X5内核也提供了主资源预拉取的接口，并且考虑到预拉取的cookie问题，还提供了preconnect预链接。<br><em>TIP:主资源中关联的子资源预拉取不用主动调用</em></p>\n<ul>\n<li>预先操作</li>\n</ul>\n<p>另外为了提供更加极致的优化，X5内核(QQ浏览器、手Q Webview)还提供了如下诸多预操作：</p>\n<ul>\n<li>在”黏贴并转到”之前就开始进行网络请求和预渲染</li>\n<li>经常访问的站点可以预解析DNS</li>\n<li>点击地址栏时进行搜索预连接</li>\n<li>点击链接时，先预链接，再做跳转。</li>\n<li>……</li>\n</ul>\n<h3 id=\"其他方式优化\"><a href=\"#其他方式优化\" class=\"headerlink\" title=\"其他方式优化\"></a>其他方式优化</h3><p>实际上上文主要讲了客户端方面的优化工作，实际上对于”云”、”管”两端，还是有很多优化工作可以讲的，但是由于这个和前端关系不是特别密切，我挑一部分讲一讲。这些在我们前端做个人项目的后台时候也可以参考</p>\n<h5 id=\"后台提速\"><a href=\"#后台提速\" class=\"headerlink\" title=\"后台提速\"></a>后台提速</h5><ul>\n<li>直接使用IP，节省dns的查询时间</li>\n<li>维持长连接</li>\n<li>HTTP1.1启用包头节省</li>\n<li>服务器缓存</li>\n<li>文本资源压缩传输GZIP(6)</li>\n<li>图片尺寸压缩、图片质量压缩、支持webp和sharpp/hevc格式。</li>\n</ul>\n<h5 id=\"降低网络时延\"><a href=\"#降低网络时延\" class=\"headerlink\" title=\"降低网络时延\"></a>降低网络时延</h5><ul>\n<li>就快接入和就近接入</li>\n</ul>\n<p>在选择接入点的时候，如果采用就近接入，可以保持路由稳定，有利于负载均衡，并且实现简单，便于维护。但是也有一定的缺点：经验判断，准确度不够高 ； 无法自动切换路由。</p>\n<p>相比较而言，选择就快接入，是一个能够提效的方式。</p>\n<h5 id=\"内容防劫持\"><a href=\"#内容防劫持\" class=\"headerlink\" title=\"内容防劫持\"></a>内容防劫持</h5><p>运营商劫持对我们来说已经是不陌生的话题了，但是X5内核有一个比较新的防劫持手段，就是客户端和云加速服务器同时采用轻量级http加密，虽然这种方式普适性不强，但是的确可以解决腾讯自身业务的防劫持问题。</p>\n<h4 id=\"QUIC和http2\"><a href=\"#QUIC和http2\" class=\"headerlink\" title=\"QUIC和http2\"></a>QUIC和http2</h4><p>QUIC 基于UDP的协议通讯方式，有这些优势：</p>\n<ul>\n<li>延迟少</li>\n<li>前向纠错</li>\n<li>没有<strong>线头阻塞[注1]</strong>的多路复用</li>\n<li>通信通道的定义基于ID而不是IP+端口，使得切换网络后继续转发链接成为可能</li>\n</ul>\n<p>——————</p>\n<p>注1：线头阻塞：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/P4.png\" alt=\"\"></p>\n<p>——————</p>\n<p>附1: 带宽和延迟对网页加载的影响：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender2/X1.png\" alt=\"\"></p>\n"},{"title":"深入浏览器web渲染与优化","date":"2017-08-27T09:37:22.000Z","_content":">本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","source":"_posts/深入浏览器web渲染与优化.md","raw":"---\ntitle: 深入浏览器web渲染与优化\ndate: 2017-08-27 17:37:22\ntags:\n    - 性能优化\n---\n>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。\n\n文章主要分为以下几个部分：\n\n* blink内核的渲染机制\n* chrome内核架构变迁\n* 分层渲染\n* 动画 & canvas & WebGl\n\n*这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分*\n\n### blink内核的渲染机制\n\nblink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。\n\n一个页面的显示，实际上主要经历了下面的四个流程：\n\n加载 => 解析 => 排版 => 渲染\n\n实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。\n\n![](https://www.10000h.top/images/data_img/webRender/P6.PNG)\n\n目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：\n\n* 浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。\n* 处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。\n* 之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。\n\n以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。\n\n另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。\n\n绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：\n\n* 硬件加速合成上屏\n* 2D Canvas、Video的硬件加速\n* GPU光栅化\n\t* GPU光栅化速度更快，内存和CPU的消耗更少\n\t* 目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化\n\t* GPU光栅化是未来趋势\n\n\n### chrome内核架构变迁\n\n在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P1.PNG)\n\n早期的chrome的架构实际上有以下缺点：\n\n* Renderer线程任务繁重\n* 无法实时响应缩放滑动操作\n* 脏区域与滑动重绘区域有冲突\n\t* 这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突\n\n当然，经过一系列的发展，Chrome现在是这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P2.PNG)\n\n在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)\n\n![](https://www.10000h.top/images/data_img/webRender/P3.PNG)\n\n当然，这种架构也有如下缺点：\n\n* UI线程过于繁忙\n* 无法支持Canvas的硬件加速以及WebGL\n\n所以，后期发展成了这样：\n\n![](https://www.10000h.top/images/data_img/webRender/P4.PNG)\n\n总结看来，内核发展的趋势是：\n\n* 多线程化(可以充分利用多核心CPU)\n* 硬件加速(可以利用GPU)\n\n### 分层渲染\n\n在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：\n\n>打开Chrome浏览器，打开控制台，找到\"Layers\"，如果没有，那么在控制台右上角更多的图标->More tools 找到\"Layers\"，然后随便找个网页打开即可\n\n网页的分层渲染流程主要是下面这样的：\n\n![](https://www.10000h.top/images/data_img/webRender/P7.PNG)\n\n(*注意：多个RenderObject可能又会对应一个或多个RenderLayer*)\n\n既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：\n\n* 减少不必要的重新绘制\n* 可以实现较为复杂的动画\n* 能够方便实现复杂的CSS样式\n\n当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：\n\n* 如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。\n* 如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。\n* 如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。\n\n那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。\n\n```\n//注:Chrome中符合创建新层的情况：\nLayer has 3D or perspective transform CSS properties(有3D元素的属性)\nLayer is used by <video> element using accelerated video decoding(video标签并使用加速视频解码)\nLayer is used by a <canvas> element with a 3D context or accelerated 2D context(canvas元素并启用3D)\nLayer is used for a composited plugin(插件，比如flash)\nLayer uses a CSS animation for its opacity or uses an animated webkit transform(CSS动画)\nLayer uses accelerated CSS filters(CSS滤镜)\nLayer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection(有一个后代元素是独立的layer)\nLayer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)(元素的相邻元素是独立layer)\n```\n\n最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：\n\n* 相对位置会发生变化的元素需要分层(比如banner图、滚动条)\n* 元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)\n* 较长较大的页面注意总的分层个数\n* 避免某一块区域分层过多，面积过大\n\n(*如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)*)\n\n另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。\n\n最后再提出一个小问题：\n\n以下哪种渲染方式是最优的呢？\n\n![](https://www.10000h.top/images/data_img/webRender/P8.PNG)\n\n这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。\n\n### 动画 & canvas & WebGl\n\n讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?\n\n对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P9.PNG)\n\n所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)\n\n另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿\n以下是一些不会触发重绘或者排版的CSS动画属性：\n\n* cursor\n* font-variant\n* opacity\n* orphans\n* perspective\n* perspecti-origin\n* pointer-events\n* transform\n* transform-style\n* widows\n\n想要了解更多内容，可以参考[这里](https://csstriggers.com/)\n\n这方面最终的建议参考如下：\n\n* 尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等\n* 动画一定要避免触发大量元素重新排版或者大面积重绘\n* 在有动画执行时，避免其他动画不相关因素引起排版和重绘\n\n\n#### requestAnimationFrame\n\n另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：\n\n![](https://www.10000h.top/images/data_img/webRender/P11.PNG)\n\n### 3D canvas\n\n还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、\n\n这个时候该怎么办呢？\n\n2D canvas上场。 \n\n和CSS动画相比，2D canvas的优点是这样的：\n\n* 硬件加速渲染\n* 渲染流程更优\n\n其渲染流程如下：\n\n![](https://www.10000h.top/images/data_img/webRender/P10.PNG)\n\n实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。\n\nHTML 2D canvas 主要绘制如下三种元素：\n\n* 图片\n* 文字\n* 矢量\n\n这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P12.PNG)\n\n硬件加速文字绘制的主要流程：\n\n![](https://www.10000h.top/images/data_img/webRender/P13.PNG)\n\n但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。\n\n对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(**所以建议是，我们如果能使用贴图就尽量使用贴图了**)\n\n还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。\n\n### 3D canvas(WebGL)\n\n目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:\n\n\n* 通用引擎：threeJS、Pixi\n* VR视频的专业引擎：krpano、UtoVR\n* H5游戏引擎：Egret、Layabox、Cocos\n\nWebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。\n\nX5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。\n\n___\n\n本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。\n\n其他优质好文：\n\n[Javascript高性能动画与页面渲染](http://qingbob.com/javascript-high-performance-animation-and-page-rendering/)\n\n\n","slug":"深入浏览器web渲染与优化","published":1,"updated":"2020-02-17T12:50:55.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6qgo6o9000e8zomodwxrza9","content":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\" alt=\"\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\" alt=\"\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\" alt=\"\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\" alt=\"\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\" alt=\"\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\" alt=\"\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\" alt=\"\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\" alt=\"\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\" alt=\"\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\" alt=\"\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\" alt=\"\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\" alt=\"\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\" target=\"_blank\" rel=\"noopener\">Javascript高性能动画与页面渲染</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文主要分析和总结web内核渲染的相关内容，以及在这方面前端可以做的性能优化工作。</p>\n</blockquote>\n<p>文章主要分为以下几个部分：</p>\n<ul>\n<li>blink内核的渲染机制</li>\n<li>chrome内核架构变迁</li>\n<li>分层渲染</li>\n<li>动画 &amp; canvas &amp; WebGl</li>\n</ul>\n<p><em>这里的前两部分可能会有些枯燥，如果是前端工程师并且想立即获得实际项目的建议的，可以直接阅读第三部分和第四部分</em></p>\n<h3 id=\"blink内核的渲染机制\"><a href=\"#blink内核的渲染机制\" class=\"headerlink\" title=\"blink内核的渲染机制\"></a>blink内核的渲染机制</h3><p>blink内核是Google基于Webkit内核开发的新的分支，而实际上，目前Chrome已经采用了blink内核，所以，我们接下来的有关分析大多基于blink内核的浏览器(Chrome)，就不再详细指明，当然，部分内容也会涉及到腾讯研发的X5内核(X5内核基于安卓的WebView，目前已经在手机QQ等产品中使用，基于X5内核的项目累计有数亿UV，上百亿PV)。</p>\n<p>一个页面的显示，实际上主要经历了下面的四个流程：</p>\n<p>加载 =&gt; 解析 =&gt; 排版 =&gt; 渲染</p>\n<p>实际上，这里的渲染主要是指排版之后到最后的上屏绘制(这个时候内容已经排版好了)，一部分前端工程师通常会把一部分的排版工作理解到“渲染”的流程中(也就是下图中全部工作)，实际上这个理解是不准确的。</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P6.PNG\" alt=\"\"></p>\n<p>目前，浏览器的渲染采用的是分块渲染的机制，所谓的分块渲染的机制，其实应该这么理解：</p>\n<ul>\n<li>浏览器首先把整个网页分成一些低分辨率的块，再把网页分成高分辨率的块，然后给这些块排列优先级。</li>\n<li>处在可视区域内的低分辨率块的优先级会比较高，会被较先绘制。</li>\n<li>之后浏览器会把高分辨率的块进行绘制，同样也是先绘制处于可视区域内的，再绘制可视区域外的(由近到远)。</li>\n</ul>\n<p>以上讲的这些策略可以使可以使得浏览器优先展示可视区域内的内容，并且先展示大致内容，再展示高精度内容(当然，由于这个过程比较快，实际上我们大多时候是感受不到的)。</p>\n<p>另外这里值得提醒的一点是，分块的优先级是会根据到可视区域的距离来决定的，所以有些横着的内容(比如banner的滚动实现，通常会设置横向超出屏幕来表示隐藏)，也是会按照到可视区域的距离来决定优先级的。</p>\n<p>绘制的过程，可以被硬件加速，这里硬件加速的主要手段主要是指：</p>\n<ul>\n<li>硬件加速合成上屏</li>\n<li>2D Canvas、Video的硬件加速</li>\n<li>GPU光栅化<ul>\n<li>GPU光栅化速度更快，内存和CPU的消耗更少</li>\n<li>目前还没有办法对包含复杂矢量绘制的页面进行GPU光栅化</li>\n<li>GPU光栅化是未来趋势</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"chrome内核架构变迁\"><a href=\"#chrome内核架构变迁\" class=\"headerlink\" title=\"chrome内核架构变迁\"></a>chrome内核架构变迁</h3><p>在渲染架构上，chrome也是经历了诸多变迁，早期的Chrome是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P1.PNG\" alt=\"\"></p>\n<p>早期的chrome的架构实际上有以下缺点：</p>\n<ul>\n<li>Renderer线程任务繁重</li>\n<li>无法实时响应缩放滑动操作</li>\n<li>脏区域与滑动重绘区域有冲突<ul>\n<li>这里举个场景，假设一个gif，这个时候如果用户滑动，滑动新的需要绘制的内容和gif下一帧内容就会产生绘制冲突</li>\n</ul>\n</li>\n</ul>\n<p>当然，经过一系列的发展，Chrome现在是这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P2.PNG\" alt=\"\"></p>\n<p>在安卓上，Android 4.4的 Blink内核架构如下(4.4之前并不支持OpenGL)</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P3.PNG\" alt=\"\"></p>\n<p>当然，这种架构也有如下缺点：</p>\n<ul>\n<li>UI线程过于繁忙</li>\n<li>无法支持Canvas的硬件加速以及WebGL</li>\n</ul>\n<p>所以，后期发展成了这样：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P4.PNG\" alt=\"\"></p>\n<p>总结看来，内核发展的趋势是：</p>\n<ul>\n<li>多线程化(可以充分利用多核心CPU)</li>\n<li>硬件加速(可以利用GPU)</li>\n</ul>\n<h3 id=\"分层渲染\"><a href=\"#分层渲染\" class=\"headerlink\" title=\"分层渲染\"></a>分层渲染</h3><p>在阅读这一章之前，我建议读者先去亲自体验一下所谓的“分层渲染”：</p>\n<blockquote>\n<p>打开Chrome浏览器，打开控制台，找到”Layers”，如果没有，那么在控制台右上角更多的图标-&gt;More tools 找到”Layers”，然后随便找个网页打开即可</p>\n</blockquote>\n<p>网页的分层渲染流程主要是下面这样的：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P7.PNG\" alt=\"\"></p>\n<p>(<em>注意：多个RenderObject可能又会对应一个或多个RenderLayer</em>)</p>\n<p>既然才用了分层渲染，那么肯定可以来分层处理，分层渲染有如下优点：</p>\n<ul>\n<li>减少不必要的重新绘制</li>\n<li>可以实现较为复杂的动画</li>\n<li>能够方便实现复杂的CSS样式</li>\n</ul>\n<p>当然，分层渲染是会很影响渲染效率的，可以有好的影响，使用不当也会有差的影响，我们需要合理的控制和使用分层：</p>\n<ul>\n<li>如果小豆腐块分层较多，页面整体的分层数量较大，会导致每帧渲染时遍历分层和计算分层位置耗时较长啊(比较典型的是腾讯网移动端首页)。</li>\n<li>如果可视区域内分层太多且需要绘制的面积太大，渲染性能非常差，甚至无法达到正常显示的地步(比如有一些全屏H5)。</li>\n<li>如果页面几乎没有分层，页面变化时候需要重绘的区域较多。元素内容无变化只有位置发生变化的时候，可以利用分层来避免重绘。</li>\n</ul>\n<p>那么，是什么原因可以导致分层呢？目前每一个浏览器或者不同版本的浏览器分层策略都是有些不同的(虽然总体差不太多)，但最常见的几个分层原因是：transform、Z-index；还有可以使用硬件加速的video、canvas；fixed元素；混合插件(flash等)。关于其他更具体的内容，可以见下文。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注:Chrome中符合创建新层的情况：</span><br><span class=\"line\">Layer has <span class=\"number\">3</span>D <span class=\"keyword\">or</span> perspective transform CSS properties(有<span class=\"number\">3</span>D元素的属性)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> &lt;video&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">using</span> accelerated video decoding(video标签并使用加速视频解码)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">by</span> <span class=\"keyword\">a</span> &lt;canvas&gt; <span class=\"keyword\">element</span> <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"number\">3</span>D context <span class=\"keyword\">or</span> accelerated <span class=\"number\">2</span>D context(canvas元素并启用<span class=\"number\">3</span>D)</span><br><span class=\"line\">Layer is used <span class=\"keyword\">for</span> <span class=\"keyword\">a</span> composited plugin(插件，比如flash)</span><br><span class=\"line\">Layer uses <span class=\"keyword\">a</span> CSS animation <span class=\"keyword\">for</span> its opacity <span class=\"keyword\">or</span> uses <span class=\"keyword\">an</span> animated webkit transform(CSS动画)</span><br><span class=\"line\">Layer uses accelerated CSS filters(CSS滤镜)</span><br><span class=\"line\">Layer <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> composited descendant has information that needs <span class=\"built_in\">to</span> be <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> composited layer tree, such <span class=\"keyword\">as</span> <span class=\"keyword\">a</span> clip <span class=\"keyword\">or</span> reflection(有一个后代元素是独立的layer)</span><br><span class=\"line\">Layer has <span class=\"keyword\">a</span> sibling <span class=\"keyword\">with</span> <span class=\"keyword\">a</span> <span class=\"built_in\">lower</span> z-index which has <span class=\"keyword\">a</span> compositing layer (<span class=\"keyword\">in</span> other <span class=\"keyword\">words</span> <span class=\"keyword\">the</span> layer is rendered <span class=\"keyword\">on</span> <span class=\"title\">top</span> <span class=\"title\">of</span> <span class=\"title\">a</span> <span class=\"title\">composited</span> <span class=\"title\">layer</span>)(元素的相邻元素是独立<span class=\"title\">layer</span>)</span><br></pre></td></tr></table></figure>\n<p>最后，我们总结一下如何合理的设计分层：分层总的原则是，减少渲染重绘面积与减少分层个数和分层总面积：</p>\n<ul>\n<li>相对位置会发生变化的元素需要分层(比如banner图、滚动条)</li>\n<li>元素内容更新比较频繁的需要分层(比如页面中夹杂的倒计时等)</li>\n<li>较长较大的页面注意总的分层个数</li>\n<li>避免某一块区域分层过多，面积过大</li>\n</ul>\n<p>(<em>如果你给一个元素添加上了-webkit-transform: translateZ(0);或者 -webkit-transform: translate3d(0,0,0);属性，那么你就等于告诉了浏览器用GPU来渲染该层，与一般的CPU渲染相比，提升了速度和性能。(我很确定这么做会在Chrome中启用了硬件加速，但在其他平台不做保证。就我得到的资料而言，在大多数浏览器比如Firefox、Safari也是适用的)</em>)</p>\n<p>另外值得一提的是，X5对分层方面做了一定的优化工作，当其检测到分层过多可能会出现显示问题的时候会进行层合并，牺牲显示性能换取显示正确性。</p>\n<p>最后再提出一个小问题：</p>\n<p>以下哪种渲染方式是最优的呢？</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P8.PNG\" alt=\"\"></p>\n<p>这里实际上后者虽然在分层上满足总体原则，但是之前讲到浏览器的分块渲染机制，是按照到可视区域的距离排序的，考虑到这个因素，实际上后者这种方式可能会对分块渲染造成一定的困扰，并且也不是最优的。</p>\n<h3 id=\"动画-amp-canvas-amp-WebGl\"><a href=\"#动画-amp-canvas-amp-WebGl\" class=\"headerlink\" title=\"动画 &amp; canvas &amp; WebGl\"></a>动画 &amp; canvas &amp; WebGl</h3><p>讲最后一部分开始，首先抛出一个问题：CSS动画 or JS动画?</p>\n<p>对内核来说，实际上就是Renderer线程动画还是Compositor线程动画，二者实际上过程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P9.PNG\" alt=\"\"></p>\n<p>所以我们可以看出，Renderer线程是比Compositor线程动画性能差的(在中低端尤其明显)</p>\n<p>另外，无论是JS动画还是CSS动画，动画过程中的重绘以及样式变化都会拖慢动画执行以及引起卡顿<br>以下是一些不会触发重绘或者排版的CSS动画属性：</p>\n<ul>\n<li>cursor</li>\n<li>font-variant</li>\n<li>opacity</li>\n<li>orphans</li>\n<li>perspective</li>\n<li>perspecti-origin</li>\n<li>pointer-events</li>\n<li>transform</li>\n<li>transform-style</li>\n<li>widows</li>\n</ul>\n<p>想要了解更多内容，可以参考<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>这方面最终的建议参考如下：</p>\n<ul>\n<li>尽量使用不会引起重绘的CSS属性动画，例如transform、opacity等</li>\n<li>动画一定要避免触发大量元素重新排版或者大面积重绘</li>\n<li>在有动画执行时，避免其他动画不相关因素引起排版和重绘</li>\n</ul>\n<h4 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h4><p>另外当我们在使用动画的时候，为了避免出现掉帧的情况，最好采用requestAnimationFrame这个API，这个API迎合浏览器的流程，并且能够保证在下一帧绘制的时候上一帧一定出现了：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P11.PNG\" alt=\"\"></p>\n<h3 id=\"3D-canvas\"><a href=\"#3D-canvas\" class=\"headerlink\" title=\"3D canvas\"></a>3D canvas</h3><p>还有值得注意的是，有的时候我们需要涉及大量元素的动画(比如雪花飘落、多个不规则图形变化等)，这个时候如果用CSS动画，Animation动画的元素很多。，导致分层个数非常多，浏览器每帧都需要遍历计算所有分层，导致比较耗时、</p>\n<p>这个时候该怎么办呢？</p>\n<p>2D canvas上场。 </p>\n<p>和CSS动画相比，2D canvas的优点是这样的：</p>\n<ul>\n<li>硬件加速渲染</li>\n<li>渲染流程更优</li>\n</ul>\n<p>其渲染流程如下：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P10.PNG\" alt=\"\"></p>\n<p>实际上以上流程比较耗时的是JS Call这一部分，执行opengl的这一部分还是挺快的。</p>\n<p>HTML 2D canvas 主要绘制如下三种元素：</p>\n<ul>\n<li>图片</li>\n<li>文字</li>\n<li>矢量</li>\n</ul>\n<p>这个过程可以采用硬件加速，硬件加速图片绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P12.PNG\" alt=\"\"></p>\n<p>硬件加速文字绘制的主要流程：</p>\n<p><img src=\"https://www.10000h.top/images/data_img/webRender/P13.PNG\" alt=\"\"></p>\n<p>但对于矢量绘制而言，简单的图形，比如点、直线等可以直接使用OpenGL渲染，复杂的图形，如曲线等，无法采用OpenGL绘制。</p>\n<p>对于绘制效率来说，2D Canvas对绘制图片效率较高，绘制文字和矢量效率较低(<strong>所以建议是，我们如果能使用贴图就尽量使用贴图了</strong>)</p>\n<p>还有，有的时候我们需要先绘制到离屏canvas上面，然后再上屏，这个可以充分利用缓存。</p>\n<h3 id=\"3D-canvas-WebGL\"><a href=\"#3D-canvas-WebGL\" class=\"headerlink\" title=\"3D canvas(WebGL)\"></a>3D canvas(WebGL)</h3><p>目前，3D canvas(WebGL)的应用也越来越多，对于这类应用，现在已经有了不少已经成型的庫:</p>\n<ul>\n<li>通用引擎：threeJS、Pixi</li>\n<li>VR视频的专业引擎：krpano、UtoVR</li>\n<li>H5游戏引擎：Egret、Layabox、Cocos</li>\n</ul>\n<p>WebGL虽然包含Web，但本身对前端的要求最低，但是对OpenGL、数学相关的知识要求较高，所以如果前端工程师没有一定的基础，还是采用现在的流行庫。</p>\n<p>X5内核对于WebGl进行了性能上和耗电上的优化，并且也对兼容性错误上报和修复做了一定的工作。</p>\n<hr>\n<p>本文参考腾讯内部讲座资料整理而成，并融入一部分笔者的补充，谢绝任何形式的转载。</p>\n<p>其他优质好文：</p>\n<p><a href=\"http://qingbob.com/javascript-high-performance-animation-and-page-rendering/\" target=\"_blank\" rel=\"noopener\">Javascript高性能动画与页面渲染</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck6qgo6o400078zom7w3sz4gz","tag_id":"ck6qgo6o100058zom3l5lk0qb","_id":"ck6qgo6o6000a8zom44wgzay9"},{"post_id":"ck6qgo6nw00018zomo3dbodjq","tag_id":"ck6qgo6o100058zom3l5lk0qb","_id":"ck6qgo6oa000f8zom2hk2d1k2"},{"post_id":"ck6qgo6nw00018zomo3dbodjq","tag_id":"ck6qgo6o500098zom0efbmxyy","_id":"ck6qgo6oa000g8zomcs0078bw"},{"post_id":"ck6qgo6nz00038zomx11qm6o7","tag_id":"ck6qgo6o9000d8zompy0tzzfo","_id":"ck6qgo6oa000i8zomnseawkmz"},{"post_id":"ck6qgo6o300068zomuwzm55wu","tag_id":"ck6qgo6oa000h8zomohdvsv7r","_id":"ck6qgo6ob000k8zomgb714012"},{"post_id":"ck6qgo6o500088zom2a8qfby7","tag_id":"ck6qgo6oa000j8zomdwv99shb","_id":"ck6qgo6ob000m8zom51b4mkse"},{"post_id":"ck6qgo6o6000b8zom32ypes1v","tag_id":"ck6qgo6ob000l8zoml908ebni","_id":"ck6qgo6ob000p8zomyrzsgea2"},{"post_id":"ck6qgo6o6000b8zom32ypes1v","tag_id":"ck6qgo6ob000n8zom8i90iqu4","_id":"ck6qgo6ob000q8zomkxzlr3zq"},{"post_id":"ck6qgo6o7000c8zommmmg8iv2","tag_id":"ck6qgo6ob000o8zomom3ai9yx","_id":"ck6qgo6oc000s8zom4i31x82y"},{"post_id":"ck6qgo6o9000e8zomodwxrza9","tag_id":"ck6qgo6ob000o8zomom3ai9yx","_id":"ck6qgo6od000t8zom8p31hkxs"}],"Tag":[{"name":"javascript","_id":"ck6qgo6o100058zom3l5lk0qb"},{"name":"前端监控","_id":"ck6qgo6o500098zom0efbmxyy"},{"name":"组件化","_id":"ck6qgo6o9000d8zompy0tzzfo"},{"name":"WebAssembly","_id":"ck6qgo6oa000h8zomohdvsv7r"},{"name":"MVVM","_id":"ck6qgo6oa000j8zomdwv99shb"},{"name":"Vue","_id":"ck6qgo6ob000l8zoml908ebni"},{"name":"viola","_id":"ck6qgo6ob000n8zom8i90iqu4"},{"name":"性能优化","_id":"ck6qgo6ob000o8zomom3ai9yx"}]}}